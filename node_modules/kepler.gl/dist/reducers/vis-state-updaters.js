"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateStateOnLayerVisibilityChange = updateStateOnLayerVisibilityChange;
exports.layerConfigChangeUpdater = layerConfigChangeUpdater;
exports.layerTextLabelChangeUpdater = layerTextLabelChangeUpdater;
exports.layerTypeChangeUpdater = layerTypeChangeUpdater;
exports.layerVisualChannelChangeUpdater = layerVisualChannelChangeUpdater;
exports.layerVisConfigChangeUpdater = layerVisConfigChangeUpdater;
exports.interactionConfigChangeUpdater = interactionConfigChangeUpdater;
exports.setFilterUpdater = setFilterUpdater;
exports.loadNextFileUpdater = loadNextFileUpdater;
exports.makeLoadFileTask = makeLoadFileTask;
exports.addDefaultLayers = addDefaultLayers;
exports.addDefaultTooltips = addDefaultTooltips;
exports.updateAllLayerDomainData = updateAllLayerDomainData;
exports.updateAnimationDomain = updateAnimationDomain;
exports.setFeaturesUpdater = setFeaturesUpdater;
exports.deleteFeatureUpdater = deleteFeatureUpdater;
exports.setPolygonFilterLayerUpdater = setPolygonFilterLayerUpdater;
exports.sortTableColumnUpdater = sortTableColumnUpdater;
exports.pinTableColumnUpdater = pinTableColumnUpdater;
exports.copyTableColumnUpdater = copyTableColumnUpdater;
exports.toggleEditorVisibility = toggleEditorVisibility;
exports.setSelectedFeatureUpdater = exports.setEditorModeUpdater = exports.setMapInfoUpdater = exports.applyCPUFilterUpdater = exports.loadFilesErrUpdater = exports.loadFilesUpdater = exports.updateVisDataUpdater = exports.toggleLayerForMapUpdater = exports.toggleSplitMapUpdater = exports.mouseMoveUpdater = exports.mapClickUpdater = exports.layerClickUpdater = exports.layerHoverUpdater = exports.receiveMapConfigUpdater = exports.resetMapConfigUpdater = exports.showDatasetTableUpdater = exports.updateLayerBlendingUpdater = exports.removeDatasetUpdater = exports.reorderLayerUpdater = exports.removeLayerUpdater = exports.addLayerUpdater = exports.removeFilterUpdater = exports.toggleFilterFeatureUpdater = exports.enlargeFilterUpdater = exports.updateLayerAnimationSpeedUpdater = exports.updateAnimationTimeUpdater = exports.updateFilterAnimationSpeedUpdater = exports.toggleFilterAnimationUpdater = exports.layerColorUIChangeUpdater = exports.addFilterUpdater = exports.setFilterPlotUpdater = exports.INITIAL_VIS_STATE = exports.DEFAULT_EDITOR = exports.defaultAnimationConfig = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _window = require("global/window");

var _tasks = require("react-palm/tasks");

var _lodash = _interopRequireDefault(require("lodash.clonedeep"));

var _lodash2 = _interopRequireDefault(require("lodash.uniq"));

var _lodash3 = _interopRequireDefault(require("lodash.get"));

var _lodash4 = _interopRequireDefault(require("lodash.xor"));

var _copyToClipboard = _interopRequireDefault(require("copy-to-clipboard"));

var _dataUtils = require("../utils/data-utils");

var _tasks2 = require("../tasks/tasks");

var _visStateActions = require("../actions/vis-state-actions");

var _interactionUtils = require("../utils/interaction-utils");

var _filterUtils = require("../utils/filter-utils");

var _gpuFilterUtils = require("../utils/gpu-filter-utils");

var _datasetUtils = require("../utils/dataset-utils");

var _utils = require("../utils/utils");

var _layerUtils = require("../utils/layer-utils/layer-utils");

var _visStateMerger = require("./vis-state-merger");

var _splitMapUtils = require("../utils/split-map-utils");

var _layers = require("../layers");

var _layerFactory = require("../layers/layer-factory");

var _defaultSettings = require("../constants/default-settings");

function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return (0, _typeof2["default"])(key) === "symbol" ? key : String(key); }

function _toPrimitive(input, hint) { if ((0, _typeof2["default"])(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if ((0, _typeof2["default"])(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// react-palm
// disable capture exception for react-palm call to withTask
(0, _tasks.disableStackCapturing)();
/**
 * Updaters for `visState` reducer. Can be used in your root reducer to directly modify kepler.gl's state.
 * Read more about [Using updaters](../advanced-usage/using-updaters.md)
 *
 * @public
 * @example
 *
 * import keplerGlReducer, {visStateUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    case 'CLICK_BUTTON':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          foo: {
 *             ...state.keplerGl.foo,
 *             visState: visStateUpdaters.enlargeFilterUpdater(
 *               state.keplerGl.foo.visState,
 *               {idx: 0}
 *             )
 *          }
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable no-unused-vars */

var visStateUpdaters = null;
/* eslint-enable no-unused-vars */

var defaultAnimationConfig = {
  domain: null,
  currentTime: null,
  speed: 1
};
exports.defaultAnimationConfig = defaultAnimationConfig;
var DEFAULT_EDITOR = {
  mode: _defaultSettings.EDITOR_MODES.DRAW_POLYGON,
  features: [],
  selectedFeature: null,
  visible: true
};
/**
 * Default initial `visState`
 * @memberof visStateUpdaters
 * @constant
 * @type {Object}
 * @property {Array} layers
 * @property {Array} layerData
 * @property {Array} layerToBeMerged
 * @property {Array} layerOrder
 * @property {Array} filters
 * @property {Array} filterToBeMerged
 * @property {Array} datasets
 * @property {string} editingDataset
 * @property {Object} interactionConfig
 * @property {Object} interactionToBeMerged
 * @property {string} layerBlending
 * @property {Object} hoverInfo
 * @property {Object} clicked
 * @property {Object} mousePos
 * @property {Array} splitMaps - a list of objects of layer availabilities and visibilities for each map
 * @property {Object} layerClasses
 * @property {Object} animationConfig
 * @property {Object} editor
 * @public
 */

exports.DEFAULT_EDITOR = DEFAULT_EDITOR;
var INITIAL_VIS_STATE = {
  // map info
  mapInfo: {
    title: '',
    description: ''
  },
  // layers
  layers: [],
  layerData: [],
  layerToBeMerged: [],
  layerOrder: [],
  // filters
  filters: [],
  filterToBeMerged: [],
  // a collection of multiple dataset
  datasets: {},
  editingDataset: undefined,
  interactionConfig: (0, _interactionUtils.getDefaultInteraction)(),
  interactionToBeMerged: undefined,
  layerBlending: 'normal',
  hoverInfo: undefined,
  clicked: undefined,
  mousePos: {},
  // this is used when user split maps
  splitMaps: [// this will contain a list of objects to
    // describe the state of layer availability and visibility for each map
    // [
    //   {
    //      layers: {layer_id: true | false}
    //   }
    // ]
  ],
  //
  // defaults layer classes
  layerClasses: _layers.LayerClasses,
  // default animation
  // time in unix timestamp (milliseconds) (the number of seconds since the Unix Epoch)
  animationConfig: defaultAnimationConfig,
  editor: DEFAULT_EDITOR
};
exports.INITIAL_VIS_STATE = INITIAL_VIS_STATE;

function updateStateWithLayerAndData(state, _ref) {
  var layerData = _ref.layerData,
      layer = _ref.layer,
      idx = _ref.idx;
  return _objectSpread({}, state, {
    layers: state.layers.map(function (lyr, i) {
      return i === idx ? layer : lyr;
    }),
    layerData: layerData ? state.layerData.map(function (d, i) {
      return i === idx ? layerData : d;
    }) : state.layerData
  });
}

function updateStateOnLayerVisibilityChange(state, layer) {
  var newState = state;

  if (state.splitMaps.length) {
    newState = _objectSpread({}, state, {
      splitMaps: layer.config.isVisible ? (0, _splitMapUtils.addNewLayersToSplitMap)(state.splitMaps, layer) : (0, _splitMapUtils.removeLayerFromSplitMaps)(state.splitMaps, layer)
    });
  }

  if (layer.config.animation.enabled) {
    newState = updateAnimationDomain(state);
  }

  return newState;
}
/**
 * Update layer base config: dataId, label, column, isVisible
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.oldLayer layer to be updated
 * @param {Object} action.newConfig new config
 * @returns {Object} nextState
 */


function layerConfigChangeUpdater(state, action) {
  var oldLayer = action.oldLayer;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var props = Object.keys(action.newConfig);
  var newLayer = oldLayer.updateLayerConfig(action.newConfig);
  var layerData; // let newLayer;

  if (newLayer.shouldCalculateLayerData(props)) {
    var oldLayerData = state.layerData[idx];
    var updateLayerDataResult = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData);
    layerData = updateLayerDataResult.layerData;
    newLayer = updateLayerDataResult.layer;
  }

  var newState = state;

  if ('isVisible' in action.newConfig) {
    newState = updateStateOnLayerVisibilityChange(state, newLayer);
  }

  return updateStateWithLayerAndData(newState, {
    layer: newLayer,
    layerData: layerData,
    idx: idx
  });
}

function addOrRemoveTextLabels(newFields, textLabel) {
  var newTextLabel = textLabel.slice();
  var currentFields = textLabel.map(function (tl) {
    return tl.field && tl.field.name;
  }).filter(function (d) {
    return d;
  });
  var addFields = newFields.filter(function (f) {
    return !currentFields.includes(f.name);
  });
  var deleteFields = currentFields.filter(function (f) {
    return !newFields.find(function (fd) {
      return fd.name === f;
    });
  }); // delete

  newTextLabel = newTextLabel.filter(function (tl) {
    return tl.field && !deleteFields.includes(tl.field.name);
  });
  newTextLabel = !newTextLabel.length ? [_layerFactory.DEFAULT_TEXT_LABEL] : newTextLabel; // add

  newTextLabel = [].concat((0, _toConsumableArray2["default"])(newTextLabel.filter(function (tl) {
    return tl.field;
  })), (0, _toConsumableArray2["default"])(addFields.map(function (af) {
    return _objectSpread({}, _layerFactory.DEFAULT_TEXT_LABEL, {
      field: af
    });
  })));
  return newTextLabel;
}

function updateTextLabelPropAndValue(idx, prop, value, textLabel) {
  if (!textLabel[idx].hasOwnProperty(prop)) {
    return textLabel;
  }

  var newTextLabel = textLabel.slice();

  if (prop && (value || textLabel.length === 1)) {
    newTextLabel = textLabel.map(function (tl, i) {
      return i === idx ? _objectSpread({}, tl, (0, _defineProperty2["default"])({}, prop, value)) : tl;
    });
  } else if (prop === 'field' && value === null && textLabel.length > 1) {
    // remove label when field value is set to null
    newTextLabel.splice(idx, 1);
  }

  return newTextLabel;
}

function layerTextLabelChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
      idx = action.idx,
      prop = action.prop,
      value = action.value;
  var textLabel = oldLayer.config.textLabel;
  var newTextLabel = textLabel.slice();

  if (!textLabel[idx] && idx === textLabel.length) {
    // if idx is set to length, add empty text label
    newTextLabel = [].concat((0, _toConsumableArray2["default"])(textLabel), [_layerFactory.DEFAULT_TEXT_LABEL]);
  }

  if (idx === 'all' && prop === 'fields') {
    newTextLabel = addOrRemoveTextLabels(value, textLabel);
  } else {
    newTextLabel = updateTextLabelPropAndValue(idx, prop, value, newTextLabel);
  } // update text label prop and value


  return layerConfigChangeUpdater(state, {
    oldLayer: oldLayer,
    newConfig: {
      textLabel: newTextLabel
    }
  });
}
/**
 * Update layer type. Previews layer config will be copied if applicable.
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.oldLayer layer to be updated
 * @param {string} action.newType new type
 * @returns {Object} nextState
 * @public
 */


function layerTypeChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
      newType = action.newType;

  if (!oldLayer) {
    return state;
  }

  var oldId = oldLayer.id;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldId;
  });

  if (!state.layerClasses[newType]) {
    _window.console.error("".concat(newType, " is not a valid layer type"));

    return state;
  } // get a mint layer, with new id and type
  // because deck.gl uses id to match between new and old layer.
  // If type has changed but id is the same, it will break


  var newLayer = new state.layerClasses[newType]();
  newLayer.assignConfigToLayer(oldLayer.config, oldLayer.visConfigSettings); // if (newLayer.config.dataId) {
  //   const dataset = state.datasets[newLayer.config.dataId];
  //   newLayer.updateLayerDomain(dataset);
  // }

  newLayer.updateLayerDomain(state.datasets);

  var _calculateLayerData = (0, _layerUtils.calculateLayerData)(newLayer, state),
      layerData = _calculateLayerData.layerData,
      layer = _calculateLayerData.layer;

  var newState = updateStateWithLayerAndData(state, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });

  if (layer.config.animation.enabled || oldLayer.config.animation.enabled) {
    newState = updateAnimationDomain(newState);
  } // update splitMap layer id


  if (state.splitMaps.length) {
    newState = _objectSpread({}, newState, {
      splitMaps: newState.splitMaps.map(function (settings) {
        var _settings$layers = settings.layers,
            oldLayerMap = _settings$layers[oldId],
            otherLayers = (0, _objectWithoutProperties2["default"])(_settings$layers, [oldId].map(_toPropertyKey));
        return oldId in settings.layers ? _objectSpread({}, settings, {
          layers: _objectSpread({}, otherLayers, (0, _defineProperty2["default"])({}, layer.id, oldLayerMap))
        }) : settings;
      })
    });
  }

  return newState;
}
/**
 * Update layer visual channel
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.oldLayer layer to be updated
 * @param {Object} action.newConfig new visual channel config
 * @param {string} action.channel channel to be updated
 * @returns {Object} nextState
 * @public
 */


function layerVisualChannelChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
      newConfig = action.newConfig,
      channel = action.channel;
  var dataset = state.datasets[oldLayer.config.dataId];
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var newLayer = oldLayer.updateLayerConfig(newConfig);
  newLayer.updateLayerVisualChannel(dataset, channel);
  var oldLayerData = state.layerData[idx];

  var _calculateLayerData2 = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData),
      layerData = _calculateLayerData2.layerData,
      layer = _calculateLayerData2.layer;

  return updateStateWithLayerAndData(state, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });
}
/**
 * Update layer `visConfig`
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.oldLayer layer to be updated
 * @param {Object} action.newVisConfig new visConfig as a key value map: e.g. `{opacity: 0.8}`
 * @returns {Object} nextState
 * @public
 */


function layerVisConfigChangeUpdater(state, action) {
  var oldLayer = action.oldLayer;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var props = Object.keys(action.newVisConfig);

  var newVisConfig = _objectSpread({}, oldLayer.config.visConfig, {}, action.newVisConfig);

  var newLayer = oldLayer.updateLayerConfig({
    visConfig: newVisConfig
  });

  if (newLayer.shouldCalculateLayerData(props)) {
    var oldLayerData = state.layerData[idx];

    var _calculateLayerData3 = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData),
        layerData = _calculateLayerData3.layerData,
        layer = _calculateLayerData3.layer;

    return updateStateWithLayerAndData(state, {
      layerData: layerData,
      layer: layer,
      idx: idx
    });
  }

  return updateStateWithLayerAndData(state, {
    layer: newLayer,
    idx: idx
  });
}
/* eslint-enable max-statements */

/**
 * Update `interactionConfig`
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.config new config as key value map: `{tooltip: {enabled: true}}`
 * @returns {Object} nextState
 * @public
 */


function interactionConfigChangeUpdater(state, action) {
  var config = action.config;

  var interactionConfig = _objectSpread({}, state.interactionConfig, {}, (0, _defineProperty2["default"])({}, config.id, config)); // Don't enable tooltip and brush at the same time
  // but coordinates can be shown at all time


  var contradict = ['brush', 'tooltip'];

  if (contradict.includes(config.id) && config.enabled && !state.interactionConfig[config.id].enabled) {
    // only enable one interaction at a time
    contradict.forEach(function (k) {
      if (k !== config.id) {
        interactionConfig[k] = _objectSpread({}, interactionConfig[k], {
          enabled: false
        });
      }
    });
  }

  return _objectSpread({}, state, {
    interactionConfig: interactionConfig
  });
}
/**
 * Update filter property
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.idx `idx` of filter to be updated
 * @param {string} action.prop `prop` of filter, e,g, `dataId`, `name`, `value`
 * @param {*} action.value new value
 * @param {string} datasetId used when updating a prop (dataId, name) that can be linked to multiple datasets
 * @returns {Object} nextState
 * @public
 */


function setFilterUpdater(state, action) {
  var idx = action.idx,
      prop = action.prop,
      value = action.value,
      _action$valueIndex = action.valueIndex,
      valueIndex = _action$valueIndex === void 0 ? 0 : _action$valueIndex;
  var oldFilter = state.filters[idx];
  var newFilter = (0, _utils.set)([prop], value, oldFilter);
  var newState = state;
  var _newFilter = newFilter,
      dataId = _newFilter.dataId; // Ensuring backward compatibility

  var datasetIds = (0, _utils.toArray)(dataId);

  switch (prop) {
    // TODO: Next PR for UI if we update dataId, we need to consider two cases:
    // 1. dataId is empty: create a default filter
    // 2. Add a new dataset id
    case _filterUtils.FILTER_UPDATER_PROPS.dataId:
      // if trying to update filter dataId. create an empty new filter
      newFilter = (0, _filterUtils.updateFilterDataId)(dataId);
      break;

    case _filterUtils.FILTER_UPDATER_PROPS.name:
      // we are supporting the current functionality
      // TODO: Next PR for UI filter name will only update filter name but it won't have side effects
      // we are gonna use pair of datasets and fieldIdx to update the filter
      var datasetId = newFilter.dataId[valueIndex];

      var _applyFilterFieldName = (0, _filterUtils.applyFilterFieldName)(newFilter, state.datasets[datasetId], value, valueIndex, {
        mergeDomain: false
      }),
          updatedFilter = _applyFilterFieldName.filter,
          newDataset = _applyFilterFieldName.dataset;

      if (!updatedFilter) {
        return state;
      }

      newFilter = updatedFilter;

      if (newFilter.gpu) {
        newFilter = (0, _gpuFilterUtils.setFilterGpuMode)(newFilter, state.filters);
        newFilter = (0, _gpuFilterUtils.assignGpuChannel)(newFilter, state.filters);
      }

      newState = (0, _utils.set)(['datasets', datasetId], newDataset, state); // only filter the current dataset

      break;

    case _filterUtils.FILTER_UPDATER_PROPS.layerId:
      // We need to update only datasetId/s if we have added/removed layers
      // - check for layerId changes (XOR works because of string values)
      // if no differences between layerIds, don't do any filtering
      var layerIdDifference = (0, _lodash4["default"])(newFilter.layerId, oldFilter.layerId);
      var layerDataIds = (0, _lodash2["default"])(layerIdDifference.map(function (lid) {
        return (0, _lodash3["default"])(state.layers.find(function (l) {
          return l.id === lid;
        }), ['config', 'dataId']);
      }).filter(function (d) {
        return d;
      })); // only filter datasetsIds

      datasetIds = layerDataIds; // Update newFilter dataIds

      var newDataIds = (0, _lodash2["default"])(newFilter.layerId.map(function (lid) {
        return (0, _lodash3["default"])(state.layers.find(function (l) {
          return l.id === lid;
        }), ['config', 'dataId']);
      }).filter(function (d) {
        return d;
      }));
      newFilter = _objectSpread({}, newFilter, {
        dataId: newDataIds
      });
      break;

    default:
      break;
  }

  var enlargedFilter = state.filters.find(function (f) {
    return f.enlarged;
  });

  if (enlargedFilter && enlargedFilter.id !== newFilter.id) {
    // there should be only one enlarged filter
    newFilter.enlarged = false;
  } // save new filters to newState


  newState = (0, _utils.set)(['filters', idx], newFilter, newState); // if we are currently setting a prop that only requires to filter the current
  // dataset we will pass only the current dataset to applyFiltersToDatasets and
  // updateAllLayerDomainData otherwise we pass the all list of datasets as defined in dataId

  var datasetIdsToFilter = _filterUtils.LIMITED_FILTER_EFFECT_PROPS[prop] ? [datasetIds[valueIndex]] : datasetIds; // filter data

  var filteredDatasets = (0, _filterUtils.applyFiltersToDatasets)(datasetIdsToFilter, newState.datasets, newState.filters, newState.layers);
  newState = (0, _utils.set)(['datasets'], filteredDatasets, newState); // dataId is an array
  // pass only the dataset we need to update

  newState = updateAllLayerDomainData(newState, datasetIdsToFilter, newFilter);
  return newState;
}
/**
 * Set the property of a filter plot
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.idx
 * @param {Object} action.newProp key value mapping of new prop `{yAxis: 'histogram'}`
 * @returns {Object} nextState
 * @public
 */


var setFilterPlotUpdater = function setFilterPlotUpdater(state, _ref2) {
  var idx = _ref2.idx,
      newProp = _ref2.newProp;

  var newFilter = _objectSpread({}, state.filters[idx], {}, newProp);

  var prop = Object.keys(newProp)[0];

  if (prop === 'yAxis') {
    var plotType = (0, _filterUtils.getDefaultFilterPlotType)(newFilter);

    if (plotType) {
      newFilter = _objectSpread({}, newFilter, {}, (0, _filterUtils.getFilterPlot)(_objectSpread({}, newFilter, {
        plotType: plotType
      }), state.datasets[newFilter.dataId].allData), {
        plotType: plotType
      });
    }
  }

  return _objectSpread({}, state, {
    filters: state.filters.map(function (f, i) {
      return i === idx ? newFilter : f;
    })
  });
};
/**
 * Add a new filter
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {string} action.dataId dataset `id` this new filter is associated with
 * @returns {Object} nextState
 * @public
 */


exports.setFilterPlotUpdater = setFilterPlotUpdater;

var addFilterUpdater = function addFilterUpdater(state, action) {
  return !action.dataId ? state : _objectSpread({}, state, {
    filters: [].concat((0, _toConsumableArray2["default"])(state.filters), [(0, _filterUtils.getDefaultFilter)(action.dataId)])
  });
};
/**
 * Set layer color palette ui state
 * @memberof visStateUpdaters
 * @param {Object} state
 * @param {Object} action
 * @param {Object} action.prop
 * @param {Object} action.newConfig
 */


exports.addFilterUpdater = addFilterUpdater;

var layerColorUIChangeUpdater = function layerColorUIChangeUpdater(state, _ref3) {
  var oldLayer = _ref3.oldLayer,
      prop = _ref3.prop,
      newConfig = _ref3.newConfig;
  var newLayer = oldLayer.updateLayerColorUI(prop, newConfig);
  return _objectSpread({}, state, {
    layers: state.layers.map(function (l) {
      return l.id === oldLayer.id ? newLayer : l;
    })
  });
};
/**
 * Start and end filter animation
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.idx idx of filter
 * @returns {Object} nextState
 * @public
 */


exports.layerColorUIChangeUpdater = layerColorUIChangeUpdater;

var toggleFilterAnimationUpdater = function toggleFilterAnimationUpdater(state, action) {
  return _objectSpread({}, state, {
    filters: state.filters.map(function (f, i) {
      return i === action.idx ? _objectSpread({}, f, {
        isAnimating: !f.isAnimating
      }) : f;
    })
  });
};
/**
 * Change filter animation speed
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.idx  `idx` of filter
 * @param {Number} action.speed `speed` to change it to. `speed` is a multiplier
 * @returns {Object} nextState
 * @public
 */


exports.toggleFilterAnimationUpdater = toggleFilterAnimationUpdater;

var updateFilterAnimationSpeedUpdater = function updateFilterAnimationSpeedUpdater(state, action) {
  return _objectSpread({}, state, {
    filters: state.filters.map(function (f, i) {
      return i === action.idx ? _objectSpread({}, f, {
        speed: action.speed
      }) : f;
    })
  });
};
/**
 * Reset animation config current time to a specified value
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.value the value current time will be set to
 * @returns {Object} nextState
 * @public
 *
 */


exports.updateFilterAnimationSpeedUpdater = updateFilterAnimationSpeedUpdater;

var updateAnimationTimeUpdater = function updateAnimationTimeUpdater(state, _ref4) {
  var value = _ref4.value;
  return _objectSpread({}, state, {
    animationConfig: _objectSpread({}, state.animationConfig, {
      currentTime: value
    })
  });
};
/**
 * Update animation speed with the vertical speed slider
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.speed the updated speed of the animation
 * @returns {Object} nextState
 * @public
 *
 */


exports.updateAnimationTimeUpdater = updateAnimationTimeUpdater;

var updateLayerAnimationSpeedUpdater = function updateLayerAnimationSpeedUpdater(state, _ref5) {
  var speed = _ref5.speed;
  return _objectSpread({}, state, {
    animationConfig: _objectSpread({}, state.animationConfig, {
      speed: speed
    })
  });
};
/**
 * Show larger time filter at bottom for time playback (apply to time filter only)
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.idx index of filter to enlarge
 * @returns {Object} nextState
 * @public
 */


exports.updateLayerAnimationSpeedUpdater = updateLayerAnimationSpeedUpdater;

var enlargeFilterUpdater = function enlargeFilterUpdater(state, action) {
  var isEnlarged = state.filters[action.idx].enlarged;
  return _objectSpread({}, state, {
    filters: state.filters.map(function (f, i) {
      f.enlarged = !isEnlarged && i === action.idx;
      return f;
    })
  });
};
/**
 * Toggles filter feature visibility
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.idx index of filter to enlarge
 * @returns {Object} nextState
 */


exports.enlargeFilterUpdater = enlargeFilterUpdater;

var toggleFilterFeatureUpdater = function toggleFilterFeatureUpdater(state, action) {
  var filter = state.filters[action.idx];
  var isVisible = (0, _lodash3["default"])(filter, ['value', 'properties', 'isVisible']);

  var newFilter = _objectSpread({}, filter, {
    value: (0, _filterUtils.featureToFilterValue)(filter.value, filter.id, {
      isVisible: !isVisible
    })
  });

  return _objectSpread({}, state, {
    filters: Object.assign([].concat(state.filters), (0, _defineProperty2["default"])({}, action.idx, newFilter))
  });
};
/**
 * Remove a filter
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.idx index of filter to b e removed
 * @returns {Object} nextState
 * @public
 */


exports.toggleFilterFeatureUpdater = toggleFilterFeatureUpdater;

var removeFilterUpdater = function removeFilterUpdater(state, action) {
  var idx = action.idx;
  var _state$filters$idx = state.filters[idx],
      dataId = _state$filters$idx.dataId,
      id = _state$filters$idx.id;
  var newFilters = [].concat((0, _toConsumableArray2["default"])(state.filters.slice(0, idx)), (0, _toConsumableArray2["default"])(state.filters.slice(idx + 1, state.filters.length)));
  var filteredDatasets = (0, _filterUtils.applyFiltersToDatasets)(dataId, state.datasets, newFilters, state.layers);
  var newEditor = (0, _filterUtils.getFilterIdInFeature)(state.editor.selectedFeature) === id ? _objectSpread({}, state.editor, {
    selectedFeature: null
  }) : state.editor;
  var newState = (0, _utils.set)(['filters'], newFilters, state);
  newState = (0, _utils.set)(['datasets'], filteredDatasets, newState);
  newState = (0, _utils.set)(['editor'], newEditor, newState);
  return updateAllLayerDomainData(newState, dataId);
};
/**
 * Add a new layer
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.props - new layer props
 * @returns {Object} nextState
 * @public
 */


exports.removeFilterUpdater = removeFilterUpdater;

var addLayerUpdater = function addLayerUpdater(state, action) {
  var defaultDataset = Object.keys(state.datasets)[0];
  var newLayer = new _layers.Layer(_objectSpread({
    isVisible: true,
    isConfigActive: true,
    dataId: defaultDataset
  }, action.props));
  return _objectSpread({}, state, {
    layers: [].concat((0, _toConsumableArray2["default"])(state.layers), [newLayer]),
    layerData: [].concat((0, _toConsumableArray2["default"])(state.layerData), [{}]),
    layerOrder: [].concat((0, _toConsumableArray2["default"])(state.layerOrder), [state.layerOrder.length]),
    splitMaps: (0, _splitMapUtils.addNewLayersToSplitMap)(state.splitMaps, newLayer)
  });
};
/**
 * remove layer
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.idx index of layer to b e removed
 * @returns {Object} nextState
 * @public
 */


exports.addLayerUpdater = addLayerUpdater;

var removeLayerUpdater = function removeLayerUpdater(state, _ref6) {
  var idx = _ref6.idx;
  var layers = state.layers,
      layerData = state.layerData,
      clicked = state.clicked,
      hoverInfo = state.hoverInfo;
  var layerToRemove = state.layers[idx];
  var newMaps = (0, _splitMapUtils.removeLayerFromSplitMaps)(state.splitMaps, layerToRemove);

  var newState = _objectSpread({}, state, {
    layers: [].concat((0, _toConsumableArray2["default"])(layers.slice(0, idx)), (0, _toConsumableArray2["default"])(layers.slice(idx + 1, layers.length))),
    layerData: [].concat((0, _toConsumableArray2["default"])(layerData.slice(0, idx)), (0, _toConsumableArray2["default"])(layerData.slice(idx + 1, layerData.length))),
    layerOrder: state.layerOrder.filter(function (i) {
      return i !== idx;
    }).map(function (pid) {
      return pid > idx ? pid - 1 : pid;
    }),
    clicked: layerToRemove.isLayerHovered(clicked) ? undefined : clicked,
    hoverInfo: layerToRemove.isLayerHovered(hoverInfo) ? undefined : hoverInfo,
    splitMaps: newMaps // TODO: update filters, create helper to remove layer form filter (remove layerid and dataid) if mapped

  });

  return updateAnimationDomain(newState);
};
/**
 * Reorder layer
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Array<Number>} action.order an array of layer indexes
 * @returns {Object} nextState
 * @public
 */


exports.removeLayerUpdater = removeLayerUpdater;

var reorderLayerUpdater = function reorderLayerUpdater(state, _ref7) {
  var order = _ref7.order;
  return _objectSpread({}, state, {
    layerOrder: order
  });
};
/**
 * Remove a dataset and all layers, filters, tooltip configs that based on it
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {string} action.key dataset id
 * @returns {Object} nextState
 * @public
 */


exports.reorderLayerUpdater = reorderLayerUpdater;

var removeDatasetUpdater = function removeDatasetUpdater(state, action) {
  // extract dataset key
  var datasetKey = action.key;
  var datasets = state.datasets; // check if dataset is present

  if (!datasets[datasetKey]) {
    return state;
  }
  /* eslint-disable no-unused-vars */


  var layers = state.layers,
      _state$datasets = state.datasets,
      dataset = _state$datasets[datasetKey],
      newDatasets = (0, _objectWithoutProperties2["default"])(_state$datasets, [datasetKey].map(_toPropertyKey));
  /* eslint-enable no-unused-vars */

  var indexes = layers.reduce(function (listOfIndexes, layer, index) {
    if (layer.config.dataId === datasetKey) {
      listOfIndexes.push(index);
    }

    return listOfIndexes;
  }, []); // remove layers and datasets

  var _indexes$reduce = indexes.reduce(function (_ref8, idx) {
    var currentState = _ref8.newState,
        indexCounter = _ref8.indexCounter;
    var currentIndex = idx - indexCounter;
    currentState = removeLayerUpdater(currentState, {
      idx: currentIndex
    });
    indexCounter++;
    return {
      newState: currentState,
      indexCounter: indexCounter
    };
  }, {
    newState: _objectSpread({}, state, {
      datasets: newDatasets
    }),
    indexCounter: 0
  }),
      newState = _indexes$reduce.newState; // remove filters


  var filters = state.filters.filter(function (filter) {
    return !filter.dataId.includes(datasetKey);
  }); // update interactionConfig

  var interactionConfig = state.interactionConfig;
  var _interactionConfig = interactionConfig,
      tooltip = _interactionConfig.tooltip;

  if (tooltip) {
    var config = tooltip.config;
    /* eslint-disable no-unused-vars */

    var _config$fieldsToShow = config.fieldsToShow,
        fields = _config$fieldsToShow[datasetKey],
        fieldsToShow = (0, _objectWithoutProperties2["default"])(_config$fieldsToShow, [datasetKey].map(_toPropertyKey));
    /* eslint-enable no-unused-vars */

    interactionConfig = _objectSpread({}, interactionConfig, {
      tooltip: _objectSpread({}, tooltip, {
        config: _objectSpread({}, config, {
          fieldsToShow: fieldsToShow
        })
      })
    });
  }

  return _objectSpread({}, newState, {
    filters: filters,
    interactionConfig: interactionConfig
  });
};
/**
 * update layer blending mode
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {string} action.mode one of `additive`, `normal` and `subtractive`
 * @returns {Object} nextState
 * @public
 */


exports.removeDatasetUpdater = removeDatasetUpdater;

var updateLayerBlendingUpdater = function updateLayerBlendingUpdater(state, action) {
  return _objectSpread({}, state, {
    layerBlending: action.mode
  });
};
/**
 * Display dataset table in a modal
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {string} action.dataId dataset id to show in table
 * @returns {Object} nextState
 * @public
 */


exports.updateLayerBlendingUpdater = updateLayerBlendingUpdater;

var showDatasetTableUpdater = function showDatasetTableUpdater(state, action) {
  return _objectSpread({}, state, {
    editingDataset: action.dataId
  });
};
/**
 * reset visState to initial State
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @returns {Object} nextState
 * @public
 */


exports.showDatasetTableUpdater = showDatasetTableUpdater;

var resetMapConfigUpdater = function resetMapConfigUpdater(state) {
  return _objectSpread({}, INITIAL_VIS_STATE, {}, state.initialState, {
    initialState: state.initialState
  });
};
/**
 * Propagate `visState` reducer with a new configuration. Current config will be override.
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.payload map config to be propagated
 * @param {Object} action.payload.config map config to be propagated
 * @param {Object} action.payload.option {keepExistingConfig: true | false}
 * @returns {Object} nextState
 * @public
 */


exports.resetMapConfigUpdater = resetMapConfigUpdater;

var receiveMapConfigUpdater = function receiveMapConfigUpdater(state, _ref9) {
  var _ref9$payload = _ref9.payload,
      _ref9$payload$config = _ref9$payload.config,
      config = _ref9$payload$config === void 0 ? {} : _ref9$payload$config,
      _ref9$payload$options = _ref9$payload.options,
      options = _ref9$payload$options === void 0 ? {} : _ref9$payload$options;

  if (!config.visState) {
    return state;
  }

  var _config$visState = config.visState,
      filters = _config$visState.filters,
      layers = _config$visState.layers,
      interactionConfig = _config$visState.interactionConfig,
      layerBlending = _config$visState.layerBlending,
      splitMaps = _config$visState.splitMaps,
      animationConfig = _config$visState.animationConfig;
  var keepExistingConfig = options.keepExistingConfig; // reset config if keepExistingConfig is falsy

  var mergedState = !keepExistingConfig ? resetMapConfigUpdater(state) : state;
  mergedState = (0, _visStateMerger.mergeLayers)(mergedState, layers);
  mergedState = (0, _visStateMerger.mergeFilters)(mergedState, filters);
  mergedState = (0, _visStateMerger.mergeInteractions)(mergedState, interactionConfig);
  mergedState = (0, _visStateMerger.mergeLayerBlending)(mergedState, layerBlending);
  mergedState = (0, _visStateMerger.mergeSplitMaps)(mergedState, splitMaps);
  mergedState = (0, _visStateMerger.mergeAnimationConfig)(mergedState, animationConfig);
  return mergedState;
};
/**
 * Trigger layer hover event with hovered object
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.info Object hovered, returned by deck.gl
 * @returns {Object} nextState
 * @public
 */


exports.receiveMapConfigUpdater = receiveMapConfigUpdater;

var layerHoverUpdater = function layerHoverUpdater(state, action) {
  return _objectSpread({}, state, {
    hoverInfo: action.info
  });
};
/**
 * Trigger layer click event with clicked object
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.info Object clicked, returned by deck.gl
 * @returns {Object} nextState
 * @public
 */


exports.layerHoverUpdater = layerHoverUpdater;

var layerClickUpdater = function layerClickUpdater(state, action) {
  return _objectSpread({}, state, {
    mousePos: state.interactionConfig.coordinate.enabled ? _objectSpread({}, state.mousePos, {
      pinned: state.mousePos.pinned ? null : (0, _lodash["default"])(state.mousePos)
    }) : state.mousePos,
    clicked: action.info && action.info.picked ? action.info : null
  });
};
/**
 * Trigger map click event, unselect clicked object
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @returns {Object} nextState
 * @public
 */


exports.layerClickUpdater = layerClickUpdater;

var mapClickUpdater = function mapClickUpdater(state) {
  return _objectSpread({}, state, {
    clicked: null
  });
};

exports.mapClickUpdater = mapClickUpdater;

var mouseMoveUpdater = function mouseMoveUpdater(state, _ref10) {
  var evt = _ref10.evt;

  if (Object.values(state.interactionConfig).some(function (config) {
    return config.enabled;
  })) {
    return _objectSpread({}, state, {
      mousePos: _objectSpread({}, state.mousePos, {
        mousePosition: (0, _toConsumableArray2["default"])(evt.point),
        coordinate: (0, _toConsumableArray2["default"])(evt.lngLat)
      })
    });
  }

  return state;
};
/**
 * Toggle visibility of a layer for a split map
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number|undefined} action.payload index of the split map
 * @returns {Object} nextState
 * @public
 */


exports.mouseMoveUpdater = mouseMoveUpdater;

var toggleSplitMapUpdater = function toggleSplitMapUpdater(state, action) {
  return state.splitMaps && state.splitMaps.length === 0 ? _objectSpread({}, state, {
    // maybe we should use an array to store state for a single map as well
    // if current maps length is equal to 0 it means that we are about to split the view
    splitMaps: (0, _splitMapUtils.computeSplitMapLayers)(state.layers)
  }) : closeSpecificMapAtIndex(state, action);
};
/**
 * Toggle visibility of a layer in a split map
 * @memberof visStateUpdaters
 * @param {Object} state
 * @param {Object} action
 * @param {Number} action.mapIndex index of the split map
 * @param {string} action.layerId id of the layer
 * @returns {Object} nextState
 * @public
 */


exports.toggleSplitMapUpdater = toggleSplitMapUpdater;

var toggleLayerForMapUpdater = function toggleLayerForMapUpdater(state, _ref11) {
  var mapIndex = _ref11.mapIndex,
      layerId = _ref11.layerId;
  var splitMaps = state.splitMaps;
  return _objectSpread({}, state, {
    splitMaps: splitMaps.map(function (sm, i) {
      return i === mapIndex ? _objectSpread({}, splitMaps[i], {
        layers: _objectSpread({}, splitMaps[i].layers, (0, _defineProperty2["default"])({}, layerId, !splitMaps[i].layers[layerId]))
      }) : sm;
    })
  });
};
/**
 * Add new dataset to `visState`, with option to load a map config along with the datasets
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Array<Object>|Object} action.datasets - ***required** datasets can be a dataset or an array of datasets
 * Each dataset object needs to have `info` and `data` property.
 * @param {Object} action.datasets.info -info of a dataset
 * @param {string} action.datasets.info.id - id of this dataset. If config is defined, `id` should matches the `dataId` in config.
 * @param {string} action.datasets.info.label - A display name of this dataset
 * @param {Object} action.datasets.data - ***required** The data object, in a tabular format with 2 properties `fields` and `rows`
 * @param {Array<Object>} action.datasets.data.fields - ***required** Array of fields,
 * @param {string} action.datasets.data.fields.name - ***required** Name of the field,
 * @param {Array<Array>} action.datasets.data.rows - ***required** Array of rows, in a tabular format with `fields` and `rows`
 * @param {Object} action.options option object `{centerMap: true, keepExistingConfig: false}`
 * @param {Object} action.config map config
 * @returns {Object} nextState
 * @public
 */

/* eslint-disable max-statements */


exports.toggleLayerForMapUpdater = toggleLayerForMapUpdater;

var updateVisDataUpdater = function updateVisDataUpdater(state, action) {
  // datasets can be a single data entries or an array of multiple data entries
  var config = action.config,
      options = action.options;
  var datasets = (0, _utils.toArray)(action.datasets);
  var newDataEntries = datasets.reduce(function (accu, _ref12) {
    var _ref12$info = _ref12.info,
        info = _ref12$info === void 0 ? {} : _ref12$info,
        data = _ref12.data;
    return _objectSpread({}, accu, {}, (0, _datasetUtils.createNewDataEntry)({
      info: info,
      data: data
    }, state.datasets) || {});
  }, {});

  if (!Object.keys(newDataEntries).length) {
    return state;
  } // apply config if passed from action


  var previousState = config ? receiveMapConfigUpdater(state, {
    payload: {
      config: config,
      options: options
    }
  }) : state;

  var stateWithNewData = _objectSpread({}, previousState, {
    datasets: _objectSpread({}, previousState.datasets, {}, newDataEntries)
  }); // previously saved config before data loaded


  var _stateWithNewData$fil = stateWithNewData.filterToBeMerged,
      filterToBeMerged = _stateWithNewData$fil === void 0 ? [] : _stateWithNewData$fil,
      _stateWithNewData$lay = stateWithNewData.layerToBeMerged,
      layerToBeMerged = _stateWithNewData$lay === void 0 ? [] : _stateWithNewData$lay,
      _stateWithNewData$int = stateWithNewData.interactionToBeMerged,
      interactionToBeMerged = _stateWithNewData$int === void 0 ? {} : _stateWithNewData$int,
      _stateWithNewData$spl = stateWithNewData.splitMapsToBeMerged,
      splitMapsToBeMerged = _stateWithNewData$spl === void 0 ? [] : _stateWithNewData$spl; // We need to merge layers before filters because polygon filters requires layers to be loaded

  var mergedState = (0, _visStateMerger.mergeLayers)(stateWithNewData, layerToBeMerged);
  mergedState = (0, _visStateMerger.mergeFilters)(mergedState, filterToBeMerged); // merge state with saved splitMaps

  mergedState = (0, _visStateMerger.mergeSplitMaps)(mergedState, splitMapsToBeMerged);
  var newLayers = mergedState.layers.filter(function (l) {
    return l.config.dataId in newDataEntries;
  });

  if (!newLayers.length) {
    // no layer merged, find defaults
    var result = addDefaultLayers(mergedState, newDataEntries);
    mergedState = result.state;
    newLayers = result.newLayers;
  }

  if (mergedState.splitMaps.length) {
    // if map is split, add new layers to splitMaps
    newLayers = mergedState.layers.filter(function (l) {
      return l.config.dataId in newDataEntries;
    });
    mergedState = _objectSpread({}, mergedState, {
      splitMaps: (0, _splitMapUtils.addNewLayersToSplitMap)(mergedState.splitMaps, newLayers)
    });
  } // merge state with saved interactions


  mergedState = (0, _visStateMerger.mergeInteractions)(mergedState, interactionToBeMerged); // if no tooltips merged add default tooltips

  Object.keys(newDataEntries).forEach(function (dataId) {
    var tooltipFields = mergedState.interactionConfig.tooltip.config.fieldsToShow[dataId];

    if (!Array.isArray(tooltipFields) || !tooltipFields.length) {
      mergedState = addDefaultTooltips(mergedState, newDataEntries[dataId]);
    }
  });
  var updatedState = updateAllLayerDomainData(mergedState, Object.keys(newDataEntries)); // register layer animation domain,
  // need to be called after layer data is calculated

  updatedState = updateAnimationDomain(updatedState);
  return updatedState;
};
/* eslint-enable max-statements */

/**
 * When a user clicks on the specific map closing icon
 * the application will close the selected map
 * and will merge the remaining one with the global state
 * TODO: i think in the future this action should be called merge map layers with global settings
 * @param {Object} state `visState`
 * @param {Object} action action
 * @returns {Object} nextState
 */


exports.updateVisDataUpdater = updateVisDataUpdater;

function closeSpecificMapAtIndex(state, action) {
  // retrieve layers meta data from the remaining map that we need to keep
  var indexToRetrieve = 1 - action.payload;
  var mapLayers = state.splitMaps[indexToRetrieve].layers;
  var layers = state.layers; // update layer visibility

  var newLayers = layers.map(function (layer) {
    return !mapLayers[layer.id] && layer.config.isVisible ? layer.updateLayerConfig({
      // if layer.id is not in mapLayers, it should be inVisible
      isVisible: false
    }) : layer;
  }); // delete map

  return _objectSpread({}, state, {
    layers: newLayers,
    splitMaps: []
  });
}
/**
 * Trigger file loading dispatch `addDataToMap` if succeed, or `loadFilesErr` if failed
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Array<Object>} action.files array of fileblob
 * @param {Function} action.onFinish action creator to execute after load file succeed
 * @returns {Object} nextState
 * @public
 */


var loadFilesUpdater = function loadFilesUpdater(state, action) {
  var files = action.files,
      _action$onFinish = action.onFinish,
      onFinish = _action$onFinish === void 0 ? _visStateActions.loadFileSuccess : _action$onFinish;

  if (!files.length) {
    return state;
  }

  var fileCache = [];
  return (0, _tasks.withTask)(_objectSpread({}, state, {
    fileLoading: true,
    fileLoadingProgress: 0
  }), makeLoadFileTask(files.length, files, fileCache, onFinish));
};

exports.loadFilesUpdater = loadFilesUpdater;

function loadNextFileUpdater(state, action) {
  var fileCache = action.fileCache,
      filesToLoad = action.filesToLoad,
      totalCount = action.totalCount,
      onFinish = action.onFinish;
  var fileLoadingProgress = (totalCount - filesToLoad.length) / totalCount * 100;
  return (0, _tasks.withTask)(_objectSpread({}, state, {
    fileLoadingProgress: fileLoadingProgress
  }), makeLoadFileTask(totalCount, filesToLoad, fileCache, onFinish));
}

function makeLoadFileTask(totalCount, filesToLoad, fileCache, onFinish) {
  var _filesToLoad = (0, _toArray2["default"])(filesToLoad),
      file = _filesToLoad[0],
      remainingFilesToLoad = _filesToLoad.slice(1);

  return (0, _tasks2.LOAD_FILE_TASK)({
    file: file,
    fileCache: fileCache
  }).bimap( // success
  function (result) {
    return remainingFilesToLoad.length ? (0, _visStateActions.loadNextFile)({
      fileCache: result,
      filesToLoad: remainingFilesToLoad,
      totalCount: totalCount,
      onFinish: onFinish
    }) : onFinish(result);
  }, // error
  _visStateActions.loadFilesErr);
}
/**
 * Trigger loading file error
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {*} action.error
 * @returns {Object} nextState
 * @public
 */


var loadFilesErrUpdater = function loadFilesErrUpdater(state, _ref13) {
  var error = _ref13.error;
  return _objectSpread({}, state, {
    fileLoading: false,
    fileLoadingErr: error
  });
};
/**
 * When select dataset for export, apply cpu filter to selected dataset
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action
 * @param {string} action.dataId dataset id
 * @returns {Object} nextState
 * @public
 */


exports.loadFilesErrUpdater = loadFilesErrUpdater;

var applyCPUFilterUpdater = function applyCPUFilterUpdater(state, _ref14) {
  var dataId = _ref14.dataId;
  // apply cpuFilter
  var dataIds = (0, _utils.toArray)(dataId);
  return dataIds.reduce(function (accu, id) {
    return (0, _filterUtils.filterDatasetCPU)(accu, id);
  }, state);
};
/**
 * User input to update the info of the map
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.info {title: 'hello'}
 * @returns {Object} nextState
 * @public
 */


exports.applyCPUFilterUpdater = applyCPUFilterUpdater;

var setMapInfoUpdater = function setMapInfoUpdater(state, action) {
  return _objectSpread({}, state, {
    mapInfo: _objectSpread({}, state.mapInfo, {}, action.info)
  });
};
/**
 * Helper function to update All layer domain and layer data of state
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Array<string>} datasets
 * @returns {Object} nextState
 */


exports.setMapInfoUpdater = setMapInfoUpdater;

function addDefaultLayers(state, datasets) {
  var defaultLayers = Object.values(datasets).reduce(function (accu, dataset) {
    return [].concat((0, _toConsumableArray2["default"])(accu), (0, _toConsumableArray2["default"])((0, _layerUtils.findDefaultLayer)(dataset, state.layerClasses) || []));
  }, []);
  return {
    state: _objectSpread({}, state, {
      layers: [].concat((0, _toConsumableArray2["default"])(state.layers), (0, _toConsumableArray2["default"])(defaultLayers)),
      layerOrder: [].concat((0, _toConsumableArray2["default"])(defaultLayers.map(function (_, i) {
        return state.layers.length + i;
      })), (0, _toConsumableArray2["default"])(state.layerOrder))
    }),
    newLayers: defaultLayers
  };
}
/**
 * helper function to find default tooltips
 * @param {Object} state
 * @param {Object} dataset
 * @returns {Object} nextState
 */


function addDefaultTooltips(state, dataset) {
  var tooltipFields = (0, _interactionUtils.findFieldsToShow)(dataset);

  var merged = _objectSpread({}, state.interactionConfig.tooltip.config.fieldsToShow, {}, tooltipFields);

  return (0, _utils.set)(['interactionConfig', 'tooltip', 'config', 'fieldsToShow'], merged, state);
}
/**
 * Helper function to update layer domains for an array of datasets
 * @param {Object} state
 * @param {Array|Array<string>} dataId dataset id or array of dataset ids
 * @param {Object} updatedFilter if is called by setFilter, the filter that has updated
 * @returns {Object} nextState
 */


function updateAllLayerDomainData(state, dataId, updatedFilter) {
  var dataIds = typeof dataId === 'string' ? [dataId] : dataId;
  var newLayers = [];
  var newLayerData = [];
  state.layers.forEach(function (oldLayer, i) {
    if (oldLayer.config.dataId && dataIds.includes(oldLayer.config.dataId)) {
      // No need to recalculate layer domain if filter has fixed domain
      var newLayer = updatedFilter && updatedFilter.fixedDomain ? oldLayer : oldLayer.updateLayerDomain(state.datasets, updatedFilter);

      var _calculateLayerData4 = (0, _layerUtils.calculateLayerData)(newLayer, state, state.layerData[i]),
          layerData = _calculateLayerData4.layerData,
          layer = _calculateLayerData4.layer;

      newLayers.push(layer);
      newLayerData.push(layerData);
    } else {
      newLayers.push(oldLayer);
      newLayerData.push(state.layerData[i]);
    }
  });

  var newState = _objectSpread({}, state, {
    layers: newLayers,
    layerData: newLayerData
  });

  return newState;
}

function updateAnimationDomain(state) {
  // merge all animatable layer domain and update global config
  var animatableLayers = state.layers.filter(function (l) {
    return l.config.isVisible && l.config.animation && l.config.animation.enabled && Array.isArray(l.animationDomain);
  });

  if (!animatableLayers.length) {
    return _objectSpread({}, state, {
      animationConfig: defaultAnimationConfig
    });
  }

  var mergedDomain = animatableLayers.reduce(function (accu, layer) {
    return [Math.min(accu[0], layer.animationDomain[0]), Math.max(accu[1], layer.animationDomain[1])];
  }, [Number(Infinity), -Infinity]);
  return _objectSpread({}, state, {
    animationConfig: _objectSpread({}, state.animationConfig, {
      currentTime: (0, _filterUtils.isInRange)(state.animationConfig.currentTime, mergedDomain) ? state.animationConfig.currentTime : mergedDomain[0],
      domain: mergedDomain
    })
  });
}
/**
 * Update the status of the editor
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {string} mode to set to editor to
 * @return {Object} nextState
 */


var setEditorModeUpdater = function setEditorModeUpdater(state, _ref15) {
  var mode = _ref15.mode;
  return _objectSpread({}, state, {
    editor: _objectSpread({}, state.editor, {
      mode: mode,
      selectedFeature: null
    })
  });
}; // const featureToFilterValue = (feature) => ({...feature, id: feature.id});

/**
 * Update editor features
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {[Object]} features to store
 * @return {Object} nextState
 */


exports.setEditorModeUpdater = setEditorModeUpdater;

function setFeaturesUpdater(state, _ref16) {
  var _ref16$features = _ref16.features,
      features = _ref16$features === void 0 ? [] : _ref16$features;
  var lastFeature = features.length && features[features.length - 1];

  var newState = _objectSpread({}, state, {
    editor: _objectSpread({}, state.editor, {
      // only save none filter features to editor
      features: features.filter(function (f) {
        return !(0, _filterUtils.getFilterIdInFeature)(f);
      }),
      mode: lastFeature && lastFeature.properties.isClosed ? _defaultSettings.EDITOR_MODES.EDIT : state.editor.mode
    })
  }); // Retrieve existing feature


  var selectedFeature = state.editor.selectedFeature; // If no feature is selected we can simply return since no operations

  if (!selectedFeature) {
    return newState;
  } // TODO: check if the feature has changed


  var feature = features.find(function (f) {
    return f.id === selectedFeature.id;
  }); // if feature is part of a filter

  var filterId = feature && (0, _filterUtils.getFilterIdInFeature)(feature);

  if (filterId) {
    var featureValue = (0, _filterUtils.featureToFilterValue)(feature, filterId);
    var filterIdx = state.filters.findIndex(function (fil) {
      return fil.id === filterId;
    });
    return setFilterUpdater(newState, {
      idx: filterIdx,
      prop: 'value',
      value: featureValue
    });
  }

  return newState;
}
/**
 * Set the current selected feature
 * @memberof uiStateUpdaters
 * @param {Object} state `uiState`
 * @param {[Object]} features to store
 * @return {Object} nextState
 */


var setSelectedFeatureUpdater = function setSelectedFeatureUpdater(state, _ref17) {
  var feature = _ref17.feature;
  return _objectSpread({}, state, {
    editor: _objectSpread({}, state.editor, {
      selectedFeature: feature
    })
  });
};
/**
 * Delete existing feature from filters
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {string} selectedFeatureId feature to delete
 * @return {Object} nextState
 */


exports.setSelectedFeatureUpdater = setSelectedFeatureUpdater;

function deleteFeatureUpdater(state, _ref18) {
  var feature = _ref18.feature;

  if (!feature) {
    return state;
  }

  var newState = _objectSpread({}, state, {
    editor: _objectSpread({}, state.editor, {
      selectedFeature: null
    })
  });

  if ((0, _filterUtils.getFilterIdInFeature)(feature)) {
    var filterIdx = newState.filters.findIndex(function (f) {
      return f.id === (0, _filterUtils.getFilterIdInFeature)(feature);
    });
    return filterIdx > -1 ? removeFilterUpdater(newState, {
      idx: filterIdx
    }) : newState;
  } // modify editor object


  var newEditor = _objectSpread({}, state.editor, {
    features: state.editor.features.filter(function (f) {
      return f.id !== feature.id;
    }),
    selectedFeature: null
  });

  return _objectSpread({}, state, {
    editor: newEditor
  });
}
/**
 * Toggle feature as layer filter
 * @memberof visStateUpdaters
 * @param state
 * @param {Object} payload
 * @param {string} payload.featureId
 * @param {Object} payload.layer
 * @return {Object} nextState
 */


function setPolygonFilterLayerUpdater(state, payload) {
  var layer = payload.layer,
      feature = payload.feature;
  var filterId = (0, _filterUtils.getFilterIdInFeature)(feature); // let newFilter = null;

  var filterIdx;
  var newLayerId = [layer.id];
  var newState = state; // If polygon filter already exists, we need to find out if the current layer is already included

  if (filterId) {
    filterIdx = state.filters.findIndex(function (f) {
      return f.id === filterId;
    });

    if (!state.filters[filterIdx]) {
      // what if filter doesn't exist?... not possible.
      // because features in the editor is passed in from filters and editors.
      // but we will move this feature back to editor just in case
      var noneFilterFeature = _objectSpread({}, feature, {
        properties: _objectSpread({}, feature.properties, {
          filterId: null
        })
      });

      return _objectSpread({}, state, {
        editor: _objectSpread({}, state.editor, {
          features: [].concat((0, _toConsumableArray2["default"])(state.editor.features), [noneFilterFeature]),
          selectedFeature: noneFilterFeature
        })
      });
    }

    var _ref19 = state.filters[filterIdx] || [],
        layerId = _ref19.layerId;

    var isLayerIncluded = layerId.includes(layer.id);
    var filter = state.filters[filterIdx];
    newLayerId = isLayerIncluded ? // if layer is included, remove it
    filter.layerId.filter(function (l) {
      return l !== layer.id;
    }) : [].concat((0, _toConsumableArray2["default"])(filter.layerId), [layer.id]);
  } else {
    // if we haven't create the polygon filter, create it
    var newFilter = (0, _filterUtils.generatePolygonFilter)([], feature);
    filterIdx = state.filters.length; // add feature, remove feature from eidtor

    newState = _objectSpread({}, state, {
      filters: [].concat((0, _toConsumableArray2["default"])(state.filters), [newFilter]),
      editor: _objectSpread({}, state.editor, {
        features: state.editor.features.filter(function (f) {
          return f.id !== feature.id;
        }),
        selectedFeature: newFilter.value
      })
    });
  }

  return setFilterUpdater(newState, {
    idx: filterIdx,
    prop: 'layerId',
    value: newLayerId
  });
}

function sortTableColumnUpdater(state, _ref20) {
  var dataId = _ref20.dataId,
      column = _ref20.column,
      mode = _ref20.mode;
  var dataset = state.datasets[dataId];

  if (!dataset) {
    return state;
  }

  if (!mode) {
    var currentMode = (0, _lodash3["default"])(dataset, ['sortColumn', column]);
    mode = currentMode ? Object.keys(_defaultSettings.SORT_ORDER).find(function (m) {
      return m !== currentMode;
    }) : _defaultSettings.SORT_ORDER.ASCENDING;
  }

  var sorted = (0, _datasetUtils.sortDatasetByColumn)(dataset, column, mode);
  return (0, _utils.set)(['datasets', dataId], sorted, state);
}

function pinTableColumnUpdater(state, _ref21) {
  var dataId = _ref21.dataId,
      column = _ref21.column;
  var dataset = state.datasets[dataId];

  if (!dataset) {
    return state;
  }

  var field = dataset.fields.find(function (f) {
    return f.name === column;
  });

  if (!field) {
    return state;
  }

  var pinnedColumns;

  if (Array.isArray(dataset.pinnedColumns) && dataset.pinnedColumns.includes(field.name)) {
    // unpin it
    pinnedColumns = dataset.pinnedColumns.filter(function (co) {
      return co !== field.name;
    });
  } else {
    pinnedColumns = (dataset.pinnedColumns || []).concat(field.name);
  }

  return (0, _utils.set)(['datasets', dataId, 'pinnedColumns'], pinnedColumns, state);
}

function copyTableColumnUpdater(state, _ref22) {
  var dataId = _ref22.dataId,
      column = _ref22.column;
  var dataset = state.datasets[dataId];

  if (!dataset) {
    return state;
  }

  var fieldIdx = dataset.fields.findIndex(function (f) {
    return f.name === column;
  });

  if (fieldIdx < 0) {
    return state;
  }

  var type = dataset.fields[fieldIdx].type;
  var text = dataset.allData.map(function (d) {
    return (0, _dataUtils.parseFieldValue)(d[fieldIdx], type);
  }).join('\n');
  (0, _copyToClipboard["default"])(text);
  return state;
}
/**
 * Update editor
 * @param {Object} state `visState`
 * @param visible
 * @return {Object} nextState
 */


function toggleEditorVisibility(state, _ref23) {
  var visible = _ref23.visible;
  return _objectSpread({}, state, {
    editor: _objectSpread({}, state.editor, {
      visible: !state.editor.visible
    })
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWR1Y2Vycy92aXMtc3RhdGUtdXBkYXRlcnMuanMiXSwibmFtZXMiOlsidmlzU3RhdGVVcGRhdGVycyIsImRlZmF1bHRBbmltYXRpb25Db25maWciLCJkb21haW4iLCJjdXJyZW50VGltZSIsInNwZWVkIiwiREVGQVVMVF9FRElUT1IiLCJtb2RlIiwiRURJVE9SX01PREVTIiwiRFJBV19QT0xZR09OIiwiZmVhdHVyZXMiLCJzZWxlY3RlZEZlYXR1cmUiLCJ2aXNpYmxlIiwiSU5JVElBTF9WSVNfU1RBVEUiLCJtYXBJbmZvIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImxheWVycyIsImxheWVyRGF0YSIsImxheWVyVG9CZU1lcmdlZCIsImxheWVyT3JkZXIiLCJmaWx0ZXJzIiwiZmlsdGVyVG9CZU1lcmdlZCIsImRhdGFzZXRzIiwiZWRpdGluZ0RhdGFzZXQiLCJ1bmRlZmluZWQiLCJpbnRlcmFjdGlvbkNvbmZpZyIsImludGVyYWN0aW9uVG9CZU1lcmdlZCIsImxheWVyQmxlbmRpbmciLCJob3ZlckluZm8iLCJjbGlja2VkIiwibW91c2VQb3MiLCJzcGxpdE1hcHMiLCJsYXllckNsYXNzZXMiLCJMYXllckNsYXNzZXMiLCJhbmltYXRpb25Db25maWciLCJlZGl0b3IiLCJ1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEiLCJzdGF0ZSIsImxheWVyIiwiaWR4IiwibWFwIiwibHlyIiwiaSIsImQiLCJ1cGRhdGVTdGF0ZU9uTGF5ZXJWaXNpYmlsaXR5Q2hhbmdlIiwibmV3U3RhdGUiLCJsZW5ndGgiLCJjb25maWciLCJpc1Zpc2libGUiLCJhbmltYXRpb24iLCJlbmFibGVkIiwidXBkYXRlQW5pbWF0aW9uRG9tYWluIiwibGF5ZXJDb25maWdDaGFuZ2VVcGRhdGVyIiwiYWN0aW9uIiwib2xkTGF5ZXIiLCJmaW5kSW5kZXgiLCJsIiwiaWQiLCJwcm9wcyIsIk9iamVjdCIsImtleXMiLCJuZXdDb25maWciLCJuZXdMYXllciIsInVwZGF0ZUxheWVyQ29uZmlnIiwic2hvdWxkQ2FsY3VsYXRlTGF5ZXJEYXRhIiwib2xkTGF5ZXJEYXRhIiwidXBkYXRlTGF5ZXJEYXRhUmVzdWx0IiwiYWRkT3JSZW1vdmVUZXh0TGFiZWxzIiwibmV3RmllbGRzIiwidGV4dExhYmVsIiwibmV3VGV4dExhYmVsIiwic2xpY2UiLCJjdXJyZW50RmllbGRzIiwidGwiLCJmaWVsZCIsIm5hbWUiLCJmaWx0ZXIiLCJhZGRGaWVsZHMiLCJmIiwiaW5jbHVkZXMiLCJkZWxldGVGaWVsZHMiLCJmaW5kIiwiZmQiLCJERUZBVUxUX1RFWFRfTEFCRUwiLCJhZiIsInVwZGF0ZVRleHRMYWJlbFByb3BBbmRWYWx1ZSIsInByb3AiLCJ2YWx1ZSIsImhhc093blByb3BlcnR5Iiwic3BsaWNlIiwibGF5ZXJUZXh0TGFiZWxDaGFuZ2VVcGRhdGVyIiwibGF5ZXJUeXBlQ2hhbmdlVXBkYXRlciIsIm5ld1R5cGUiLCJvbGRJZCIsIkNvbnNvbGUiLCJlcnJvciIsImFzc2lnbkNvbmZpZ1RvTGF5ZXIiLCJ2aXNDb25maWdTZXR0aW5ncyIsInVwZGF0ZUxheWVyRG9tYWluIiwic2V0dGluZ3MiLCJvbGRMYXllck1hcCIsIm90aGVyTGF5ZXJzIiwibGF5ZXJWaXN1YWxDaGFubmVsQ2hhbmdlVXBkYXRlciIsImNoYW5uZWwiLCJkYXRhc2V0IiwiZGF0YUlkIiwidXBkYXRlTGF5ZXJWaXN1YWxDaGFubmVsIiwibGF5ZXJWaXNDb25maWdDaGFuZ2VVcGRhdGVyIiwibmV3VmlzQ29uZmlnIiwidmlzQ29uZmlnIiwiaW50ZXJhY3Rpb25Db25maWdDaGFuZ2VVcGRhdGVyIiwiY29udHJhZGljdCIsImZvckVhY2giLCJrIiwic2V0RmlsdGVyVXBkYXRlciIsInZhbHVlSW5kZXgiLCJvbGRGaWx0ZXIiLCJuZXdGaWx0ZXIiLCJkYXRhc2V0SWRzIiwiRklMVEVSX1VQREFURVJfUFJPUFMiLCJkYXRhc2V0SWQiLCJtZXJnZURvbWFpbiIsInVwZGF0ZWRGaWx0ZXIiLCJuZXdEYXRhc2V0IiwiZ3B1IiwibGF5ZXJJZCIsImxheWVySWREaWZmZXJlbmNlIiwibGF5ZXJEYXRhSWRzIiwibGlkIiwibmV3RGF0YUlkcyIsImVubGFyZ2VkRmlsdGVyIiwiZW5sYXJnZWQiLCJkYXRhc2V0SWRzVG9GaWx0ZXIiLCJMSU1JVEVEX0ZJTFRFUl9FRkZFQ1RfUFJPUFMiLCJmaWx0ZXJlZERhdGFzZXRzIiwidXBkYXRlQWxsTGF5ZXJEb21haW5EYXRhIiwic2V0RmlsdGVyUGxvdFVwZGF0ZXIiLCJuZXdQcm9wIiwicGxvdFR5cGUiLCJhbGxEYXRhIiwiYWRkRmlsdGVyVXBkYXRlciIsImxheWVyQ29sb3JVSUNoYW5nZVVwZGF0ZXIiLCJ1cGRhdGVMYXllckNvbG9yVUkiLCJ0b2dnbGVGaWx0ZXJBbmltYXRpb25VcGRhdGVyIiwiaXNBbmltYXRpbmciLCJ1cGRhdGVGaWx0ZXJBbmltYXRpb25TcGVlZFVwZGF0ZXIiLCJ1cGRhdGVBbmltYXRpb25UaW1lVXBkYXRlciIsInVwZGF0ZUxheWVyQW5pbWF0aW9uU3BlZWRVcGRhdGVyIiwiZW5sYXJnZUZpbHRlclVwZGF0ZXIiLCJpc0VubGFyZ2VkIiwidG9nZ2xlRmlsdGVyRmVhdHVyZVVwZGF0ZXIiLCJhc3NpZ24iLCJjb25jYXQiLCJyZW1vdmVGaWx0ZXJVcGRhdGVyIiwibmV3RmlsdGVycyIsIm5ld0VkaXRvciIsImFkZExheWVyVXBkYXRlciIsImRlZmF1bHREYXRhc2V0IiwiTGF5ZXIiLCJpc0NvbmZpZ0FjdGl2ZSIsInJlbW92ZUxheWVyVXBkYXRlciIsImxheWVyVG9SZW1vdmUiLCJuZXdNYXBzIiwicGlkIiwiaXNMYXllckhvdmVyZWQiLCJyZW9yZGVyTGF5ZXJVcGRhdGVyIiwib3JkZXIiLCJyZW1vdmVEYXRhc2V0VXBkYXRlciIsImRhdGFzZXRLZXkiLCJrZXkiLCJuZXdEYXRhc2V0cyIsImluZGV4ZXMiLCJyZWR1Y2UiLCJsaXN0T2ZJbmRleGVzIiwiaW5kZXgiLCJwdXNoIiwiY3VycmVudFN0YXRlIiwiaW5kZXhDb3VudGVyIiwiY3VycmVudEluZGV4IiwidG9vbHRpcCIsImZpZWxkc1RvU2hvdyIsImZpZWxkcyIsInVwZGF0ZUxheWVyQmxlbmRpbmdVcGRhdGVyIiwic2hvd0RhdGFzZXRUYWJsZVVwZGF0ZXIiLCJyZXNldE1hcENvbmZpZ1VwZGF0ZXIiLCJpbml0aWFsU3RhdGUiLCJyZWNlaXZlTWFwQ29uZmlnVXBkYXRlciIsInBheWxvYWQiLCJvcHRpb25zIiwidmlzU3RhdGUiLCJrZWVwRXhpc3RpbmdDb25maWciLCJtZXJnZWRTdGF0ZSIsImxheWVySG92ZXJVcGRhdGVyIiwiaW5mbyIsImxheWVyQ2xpY2tVcGRhdGVyIiwiY29vcmRpbmF0ZSIsInBpbm5lZCIsInBpY2tlZCIsIm1hcENsaWNrVXBkYXRlciIsIm1vdXNlTW92ZVVwZGF0ZXIiLCJldnQiLCJ2YWx1ZXMiLCJzb21lIiwibW91c2VQb3NpdGlvbiIsInBvaW50IiwibG5nTGF0IiwidG9nZ2xlU3BsaXRNYXBVcGRhdGVyIiwiY2xvc2VTcGVjaWZpY01hcEF0SW5kZXgiLCJ0b2dnbGVMYXllckZvck1hcFVwZGF0ZXIiLCJtYXBJbmRleCIsInNtIiwidXBkYXRlVmlzRGF0YVVwZGF0ZXIiLCJuZXdEYXRhRW50cmllcyIsImFjY3UiLCJkYXRhIiwicHJldmlvdXNTdGF0ZSIsInN0YXRlV2l0aE5ld0RhdGEiLCJzcGxpdE1hcHNUb0JlTWVyZ2VkIiwibmV3TGF5ZXJzIiwicmVzdWx0IiwiYWRkRGVmYXVsdExheWVycyIsInRvb2x0aXBGaWVsZHMiLCJBcnJheSIsImlzQXJyYXkiLCJhZGREZWZhdWx0VG9vbHRpcHMiLCJ1cGRhdGVkU3RhdGUiLCJpbmRleFRvUmV0cmlldmUiLCJtYXBMYXllcnMiLCJsb2FkRmlsZXNVcGRhdGVyIiwiZmlsZXMiLCJvbkZpbmlzaCIsImxvYWRGaWxlU3VjY2VzcyIsImZpbGVDYWNoZSIsImZpbGVMb2FkaW5nIiwiZmlsZUxvYWRpbmdQcm9ncmVzcyIsIm1ha2VMb2FkRmlsZVRhc2siLCJsb2FkTmV4dEZpbGVVcGRhdGVyIiwiZmlsZXNUb0xvYWQiLCJ0b3RhbENvdW50IiwiZmlsZSIsInJlbWFpbmluZ0ZpbGVzVG9Mb2FkIiwiYmltYXAiLCJsb2FkRmlsZXNFcnIiLCJsb2FkRmlsZXNFcnJVcGRhdGVyIiwiZmlsZUxvYWRpbmdFcnIiLCJhcHBseUNQVUZpbHRlclVwZGF0ZXIiLCJkYXRhSWRzIiwic2V0TWFwSW5mb1VwZGF0ZXIiLCJkZWZhdWx0TGF5ZXJzIiwiXyIsIm1lcmdlZCIsIm5ld0xheWVyRGF0YSIsImZpeGVkRG9tYWluIiwiYW5pbWF0YWJsZUxheWVycyIsImFuaW1hdGlvbkRvbWFpbiIsIm1lcmdlZERvbWFpbiIsIk1hdGgiLCJtaW4iLCJtYXgiLCJOdW1iZXIiLCJJbmZpbml0eSIsInNldEVkaXRvck1vZGVVcGRhdGVyIiwic2V0RmVhdHVyZXNVcGRhdGVyIiwibGFzdEZlYXR1cmUiLCJwcm9wZXJ0aWVzIiwiaXNDbG9zZWQiLCJFRElUIiwiZmVhdHVyZSIsImZpbHRlcklkIiwiZmVhdHVyZVZhbHVlIiwiZmlsdGVySWR4IiwiZmlsIiwic2V0U2VsZWN0ZWRGZWF0dXJlVXBkYXRlciIsImRlbGV0ZUZlYXR1cmVVcGRhdGVyIiwic2V0UG9seWdvbkZpbHRlckxheWVyVXBkYXRlciIsIm5ld0xheWVySWQiLCJub25lRmlsdGVyRmVhdHVyZSIsImlzTGF5ZXJJbmNsdWRlZCIsInNvcnRUYWJsZUNvbHVtblVwZGF0ZXIiLCJjb2x1bW4iLCJjdXJyZW50TW9kZSIsIlNPUlRfT1JERVIiLCJtIiwiQVNDRU5ESU5HIiwic29ydGVkIiwicGluVGFibGVDb2x1bW5VcGRhdGVyIiwicGlubmVkQ29sdW1ucyIsImNvIiwiY29weVRhYmxlQ29sdW1uVXBkYXRlciIsImZpZWxkSWR4IiwidHlwZSIsInRleHQiLCJqb2luIiwidG9nZ2xlRWRpdG9yVmlzaWJpbGl0eSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFFQTs7QUFF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QUVKeEIsTUFBQUEsT0FBTyxFQUFFLENBQUMwQixLQUFLLENBQUNGLE1BQU4sQ0FBYXhCO0FBRm5CO0FBRlI7QUFPRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMCBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29uc29sZSBhcyBDb25zb2xlfSBmcm9tICdnbG9iYWwvd2luZG93JztcbmltcG9ydCB7ZGlzYWJsZVN0YWNrQ2FwdHVyaW5nLCB3aXRoVGFza30gZnJvbSAncmVhY3QtcGFsbS90YXNrcyc7XG5pbXBvcnQgY2xvbmVEZWVwIGZyb20gJ2xvZGFzaC5jbG9uZWRlZXAnO1xuaW1wb3J0IHVuaXEgZnJvbSAnbG9kYXNoLnVuaXEnO1xuaW1wb3J0IGdldCBmcm9tICdsb2Rhc2guZ2V0JztcbmltcG9ydCB4b3IgZnJvbSAnbG9kYXNoLnhvcic7XG5pbXBvcnQgY29weSBmcm9tICdjb3B5LXRvLWNsaXBib2FyZCc7XG5pbXBvcnQge3BhcnNlRmllbGRWYWx1ZX0gZnJvbSAndXRpbHMvZGF0YS11dGlscyc7XG4vLyBUYXNrc1xuaW1wb3J0IHtMT0FEX0ZJTEVfVEFTS30gZnJvbSAndGFza3MvdGFza3MnO1xuLy8gQWN0aW9uc1xuaW1wb3J0IHtsb2FkRmlsZXNFcnIsIGxvYWRGaWxlU3VjY2VzcywgbG9hZE5leHRGaWxlfSBmcm9tICdhY3Rpb25zL3Zpcy1zdGF0ZS1hY3Rpb25zJztcbi8vIFV0aWxzXG5pbXBvcnQge2ZpbmRGaWVsZHNUb1Nob3csIGdldERlZmF1bHRJbnRlcmFjdGlvbn0gZnJvbSAndXRpbHMvaW50ZXJhY3Rpb24tdXRpbHMnO1xuaW1wb3J0IHtcbiAgYXBwbHlGaWx0ZXJGaWVsZE5hbWUsXG4gIGFwcGx5RmlsdGVyc1RvRGF0YXNldHMsXG4gIGZlYXR1cmVUb0ZpbHRlclZhbHVlLFxuICBGSUxURVJfVVBEQVRFUl9QUk9QUyxcbiAgZmlsdGVyRGF0YXNldENQVSxcbiAgZ2VuZXJhdGVQb2x5Z29uRmlsdGVyLFxuICBnZXREZWZhdWx0RmlsdGVyLFxuICBnZXREZWZhdWx0RmlsdGVyUGxvdFR5cGUsXG4gIGdldEZpbHRlcklkSW5GZWF0dXJlLFxuICBnZXRGaWx0ZXJQbG90LFxuICBpc0luUmFuZ2UsXG4gIExJTUlURURfRklMVEVSX0VGRkVDVF9QUk9QUyxcbiAgdXBkYXRlRmlsdGVyRGF0YUlkXG59IGZyb20gJ3V0aWxzL2ZpbHRlci11dGlscyc7XG5pbXBvcnQge2Fzc2lnbkdwdUNoYW5uZWwsIHNldEZpbHRlckdwdU1vZGV9IGZyb20gJ3V0aWxzL2dwdS1maWx0ZXItdXRpbHMnO1xuaW1wb3J0IHtjcmVhdGVOZXdEYXRhRW50cnksIHNvcnREYXRhc2V0QnlDb2x1bW59IGZyb20gJ3V0aWxzL2RhdGFzZXQtdXRpbHMnO1xuaW1wb3J0IHtzZXQsIHRvQXJyYXl9IGZyb20gJ3V0aWxzL3V0aWxzJztcblxuaW1wb3J0IHtjYWxjdWxhdGVMYXllckRhdGEsIGZpbmREZWZhdWx0TGF5ZXJ9IGZyb20gJ3V0aWxzL2xheWVyLXV0aWxzL2xheWVyLXV0aWxzJztcblxuaW1wb3J0IHtcbiAgbWVyZ2VBbmltYXRpb25Db25maWcsXG4gIG1lcmdlRmlsdGVycyxcbiAgbWVyZ2VJbnRlcmFjdGlvbnMsXG4gIG1lcmdlTGF5ZXJCbGVuZGluZyxcbiAgbWVyZ2VMYXllcnMsXG4gIG1lcmdlU3BsaXRNYXBzXG59IGZyb20gJy4vdmlzLXN0YXRlLW1lcmdlcic7XG5cbmltcG9ydCB7XG4gIGFkZE5ld0xheWVyc1RvU3BsaXRNYXAsXG4gIGNvbXB1dGVTcGxpdE1hcExheWVycyxcbiAgcmVtb3ZlTGF5ZXJGcm9tU3BsaXRNYXBzXG59IGZyb20gJ3V0aWxzL3NwbGl0LW1hcC11dGlscyc7XG5cbmltcG9ydCB7TGF5ZXIsIExheWVyQ2xhc3Nlc30gZnJvbSAnbGF5ZXJzJztcbmltcG9ydCB7REVGQVVMVF9URVhUX0xBQkVMfSBmcm9tICdsYXllcnMvbGF5ZXItZmFjdG9yeSc7XG5pbXBvcnQge0VESVRPUl9NT0RFUywgU09SVF9PUkRFUn0gZnJvbSAnY29uc3RhbnRzL2RlZmF1bHQtc2V0dGluZ3MnO1xuXG4vLyByZWFjdC1wYWxtXG4vLyBkaXNhYmxlIGNhcHR1cmUgZXhjZXB0aW9uIGZvciByZWFjdC1wYWxtIGNhbGwgdG8gd2l0aFRhc2tcbmRpc2FibGVTdGFja0NhcHR1cmluZygpO1xuXG4vKipcbiAqIFVwZGF0ZXJzIGZvciBgdmlzU3RhdGVgIHJlZHVjZXIuIENhbiBiZSB1c2VkIGluIHlvdXIgcm9vdCByZWR1Y2VyIHRvIGRpcmVjdGx5IG1vZGlmeSBrZXBsZXIuZ2wncyBzdGF0ZS5cbiAqIFJlYWQgbW9yZSBhYm91dCBbVXNpbmcgdXBkYXRlcnNdKC4uL2FkdmFuY2VkLXVzYWdlL3VzaW5nLXVwZGF0ZXJzLm1kKVxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IGtlcGxlckdsUmVkdWNlciwge3Zpc1N0YXRlVXBkYXRlcnN9IGZyb20gJ2tlcGxlci5nbC9yZWR1Y2Vycyc7XG4gKiAvLyBSb290IFJlZHVjZXJcbiAqIGNvbnN0IHJlZHVjZXJzID0gY29tYmluZVJlZHVjZXJzKHtcbiAqICBrZXBsZXJHbDoga2VwbGVyR2xSZWR1Y2VyLFxuICogIGFwcDogYXBwUmVkdWNlclxuICogfSk7XG4gKlxuICogY29uc3QgY29tcG9zZWRSZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAqICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gKiAgICBjYXNlICdDTElDS19CVVRUT04nOlxuICogICAgICByZXR1cm4ge1xuICogICAgICAgIC4uLnN0YXRlLFxuICogICAgICAgIGtlcGxlckdsOiB7XG4gKiAgICAgICAgICAuLi5zdGF0ZS5rZXBsZXJHbCxcbiAqICAgICAgICAgIGZvbzoge1xuICogICAgICAgICAgICAgLi4uc3RhdGUua2VwbGVyR2wuZm9vLFxuICogICAgICAgICAgICAgdmlzU3RhdGU6IHZpc1N0YXRlVXBkYXRlcnMuZW5sYXJnZUZpbHRlclVwZGF0ZXIoXG4gKiAgICAgICAgICAgICAgIHN0YXRlLmtlcGxlckdsLmZvby52aXNTdGF0ZSxcbiAqICAgICAgICAgICAgICAge2lkeDogMH1cbiAqICAgICAgICAgICAgIClcbiAqICAgICAgICAgIH1cbiAqICAgICAgICB9XG4gKiAgICAgIH07XG4gKiAgfVxuICogIHJldHVybiByZWR1Y2VycyhzdGF0ZSwgYWN0aW9uKTtcbiAqIH07XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgY29tcG9zZWRSZWR1Y2VyO1xuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuY29uc3QgdmlzU3RhdGVVcGRhdGVycyA9IG51bGw7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0QW5pbWF0aW9uQ29uZmlnID0ge1xuICBkb21haW46IG51bGwsXG4gIGN1cnJlbnRUaW1lOiBudWxsLFxuICBzcGVlZDogMVxufTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfRURJVE9SID0ge1xuICBtb2RlOiBFRElUT1JfTU9ERVMuRFJBV19QT0xZR09OLFxuICBmZWF0dXJlczogW10sXG4gIHNlbGVjdGVkRmVhdHVyZTogbnVsbCxcbiAgdmlzaWJsZTogdHJ1ZVxufTtcblxuLyoqXG4gKiBEZWZhdWx0IGluaXRpYWwgYHZpc1N0YXRlYFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBjb25zdGFudFxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IGxheWVyc1xuICogQHByb3BlcnR5IHtBcnJheX0gbGF5ZXJEYXRhXG4gKiBAcHJvcGVydHkge0FycmF5fSBsYXllclRvQmVNZXJnZWRcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IGxheWVyT3JkZXJcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IGZpbHRlcnNcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IGZpbHRlclRvQmVNZXJnZWRcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IGRhdGFzZXRzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZWRpdGluZ0RhdGFzZXRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnRlcmFjdGlvbkNvbmZpZ1xuICogQHByb3BlcnR5IHtPYmplY3R9IGludGVyYWN0aW9uVG9CZU1lcmdlZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxheWVyQmxlbmRpbmdcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBob3ZlckluZm9cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjbGlja2VkXG4gKiBAcHJvcGVydHkge09iamVjdH0gbW91c2VQb3NcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IHNwbGl0TWFwcyAtIGEgbGlzdCBvZiBvYmplY3RzIG9mIGxheWVyIGF2YWlsYWJpbGl0aWVzIGFuZCB2aXNpYmlsaXRpZXMgZm9yIGVhY2ggbWFwXG4gKiBAcHJvcGVydHkge09iamVjdH0gbGF5ZXJDbGFzc2VzXG4gKiBAcHJvcGVydHkge09iamVjdH0gYW5pbWF0aW9uQ29uZmlnXG4gKiBAcHJvcGVydHkge09iamVjdH0gZWRpdG9yXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBJTklUSUFMX1ZJU19TVEFURSA9IHtcbiAgLy8gbWFwIGluZm9cbiAgbWFwSW5mbzoge1xuICAgIHRpdGxlOiAnJyxcbiAgICBkZXNjcmlwdGlvbjogJydcbiAgfSxcbiAgLy8gbGF5ZXJzXG4gIGxheWVyczogW10sXG4gIGxheWVyRGF0YTogW10sXG4gIGxheWVyVG9CZU1lcmdlZDogW10sXG4gIGxheWVyT3JkZXI6IFtdLFxuXG4gIC8vIGZpbHRlcnNcbiAgZmlsdGVyczogW10sXG4gIGZpbHRlclRvQmVNZXJnZWQ6IFtdLFxuXG4gIC8vIGEgY29sbGVjdGlvbiBvZiBtdWx0aXBsZSBkYXRhc2V0XG4gIGRhdGFzZXRzOiB7fSxcbiAgZWRpdGluZ0RhdGFzZXQ6IHVuZGVmaW5lZCxcblxuICBpbnRlcmFjdGlvbkNvbmZpZzogZ2V0RGVmYXVsdEludGVyYWN0aW9uKCksXG4gIGludGVyYWN0aW9uVG9CZU1lcmdlZDogdW5kZWZpbmVkLFxuXG4gIGxheWVyQmxlbmRpbmc6ICdub3JtYWwnLFxuICBob3ZlckluZm86IHVuZGVmaW5lZCxcbiAgY2xpY2tlZDogdW5kZWZpbmVkLFxuICBtb3VzZVBvczoge30sXG5cbiAgLy8gdGhpcyBpcyB1c2VkIHdoZW4gdXNlciBzcGxpdCBtYXBzXG4gIHNwbGl0TWFwczogW1xuICAgIC8vIHRoaXMgd2lsbCBjb250YWluIGEgbGlzdCBvZiBvYmplY3RzIHRvXG4gICAgLy8gZGVzY3JpYmUgdGhlIHN0YXRlIG9mIGxheWVyIGF2YWlsYWJpbGl0eSBhbmQgdmlzaWJpbGl0eSBmb3IgZWFjaCBtYXBcbiAgICAvLyBbXG4gICAgLy8gICB7XG4gICAgLy8gICAgICBsYXllcnM6IHtsYXllcl9pZDogdHJ1ZSB8IGZhbHNlfVxuICAgIC8vICAgfVxuICAgIC8vIF1cbiAgXSxcbiAgLy9cbiAgLy8gZGVmYXVsdHMgbGF5ZXIgY2xhc3Nlc1xuICBsYXllckNsYXNzZXM6IExheWVyQ2xhc3NlcyxcblxuICAvLyBkZWZhdWx0IGFuaW1hdGlvblxuICAvLyB0aW1lIGluIHVuaXggdGltZXN0YW1wIChtaWxsaXNlY29uZHMpICh0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIFVuaXggRXBvY2gpXG4gIGFuaW1hdGlvbkNvbmZpZzogZGVmYXVsdEFuaW1hdGlvbkNvbmZpZyxcblxuICBlZGl0b3I6IERFRkFVTFRfRURJVE9SXG59O1xuXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEoc3RhdGUsIHtsYXllckRhdGEsIGxheWVyLCBpZHh9KSB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBzdGF0ZS5sYXllcnMubWFwKChseXIsIGkpID0+IChpID09PSBpZHggPyBsYXllciA6IGx5cikpLFxuICAgIGxheWVyRGF0YTogbGF5ZXJEYXRhXG4gICAgICA/IHN0YXRlLmxheWVyRGF0YS5tYXAoKGQsIGkpID0+IChpID09PSBpZHggPyBsYXllckRhdGEgOiBkKSlcbiAgICAgIDogc3RhdGUubGF5ZXJEYXRhXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTdGF0ZU9uTGF5ZXJWaXNpYmlsaXR5Q2hhbmdlKHN0YXRlLCBsYXllcikge1xuICBsZXQgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgaWYgKHN0YXRlLnNwbGl0TWFwcy5sZW5ndGgpIHtcbiAgICBuZXdTdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgc3BsaXRNYXBzOiBsYXllci5jb25maWcuaXNWaXNpYmxlXG4gICAgICAgID8gYWRkTmV3TGF5ZXJzVG9TcGxpdE1hcChzdGF0ZS5zcGxpdE1hcHMsIGxheWVyKVxuICAgICAgICA6IHJlbW92ZUxheWVyRnJvbVNwbGl0TWFwcyhzdGF0ZS5zcGxpdE1hcHMsIGxheWVyKVxuICAgIH07XG4gIH1cblxuICBpZiAobGF5ZXIuY29uZmlnLmFuaW1hdGlvbi5lbmFibGVkKSB7XG4gICAgbmV3U3RhdGUgPSB1cGRhdGVBbmltYXRpb25Eb21haW4oc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBsYXllciBiYXNlIGNvbmZpZzogZGF0YUlkLCBsYWJlbCwgY29sdW1uLCBpc1Zpc2libGVcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24ub2xkTGF5ZXIgbGF5ZXIgdG8gYmUgdXBkYXRlZFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5uZXdDb25maWcgbmV3IGNvbmZpZ1xuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllckNvbmZpZ0NoYW5nZVVwZGF0ZXIoc3RhdGUsIGFjdGlvbikge1xuICBjb25zdCB7b2xkTGF5ZXJ9ID0gYWN0aW9uO1xuICBjb25zdCBpZHggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkTGF5ZXIuaWQpO1xuICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKGFjdGlvbi5uZXdDb25maWcpO1xuICBsZXQgbmV3TGF5ZXIgPSBvbGRMYXllci51cGRhdGVMYXllckNvbmZpZyhhY3Rpb24ubmV3Q29uZmlnKTtcblxuICBsZXQgbGF5ZXJEYXRhO1xuXG4gIC8vIGxldCBuZXdMYXllcjtcbiAgaWYgKG5ld0xheWVyLnNob3VsZENhbGN1bGF0ZUxheWVyRGF0YShwcm9wcykpIHtcbiAgICBjb25zdCBvbGRMYXllckRhdGEgPSBzdGF0ZS5sYXllckRhdGFbaWR4XTtcbiAgICBjb25zdCB1cGRhdGVMYXllckRhdGFSZXN1bHQgPSBjYWxjdWxhdGVMYXllckRhdGEobmV3TGF5ZXIsIHN0YXRlLCBvbGRMYXllckRhdGEpO1xuXG4gICAgbGF5ZXJEYXRhID0gdXBkYXRlTGF5ZXJEYXRhUmVzdWx0LmxheWVyRGF0YTtcbiAgICBuZXdMYXllciA9IHVwZGF0ZUxheWVyRGF0YVJlc3VsdC5sYXllcjtcbiAgfVxuXG4gIGxldCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBpZiAoJ2lzVmlzaWJsZScgaW4gYWN0aW9uLm5ld0NvbmZpZykge1xuICAgIG5ld1N0YXRlID0gdXBkYXRlU3RhdGVPbkxheWVyVmlzaWJpbGl0eUNoYW5nZShzdGF0ZSwgbmV3TGF5ZXIpO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShuZXdTdGF0ZSwge1xuICAgIGxheWVyOiBuZXdMYXllcixcbiAgICBsYXllckRhdGEsXG4gICAgaWR4XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRPclJlbW92ZVRleHRMYWJlbHMobmV3RmllbGRzLCB0ZXh0TGFiZWwpIHtcbiAgbGV0IG5ld1RleHRMYWJlbCA9IHRleHRMYWJlbC5zbGljZSgpO1xuXG4gIGNvbnN0IGN1cnJlbnRGaWVsZHMgPSB0ZXh0TGFiZWwubWFwKHRsID0+IHRsLmZpZWxkICYmIHRsLmZpZWxkLm5hbWUpLmZpbHRlcihkID0+IGQpO1xuXG4gIGNvbnN0IGFkZEZpZWxkcyA9IG5ld0ZpZWxkcy5maWx0ZXIoZiA9PiAhY3VycmVudEZpZWxkcy5pbmNsdWRlcyhmLm5hbWUpKTtcbiAgY29uc3QgZGVsZXRlRmllbGRzID0gY3VycmVudEZpZWxkcy5maWx0ZXIoZiA9PiAhbmV3RmllbGRzLmZpbmQoZmQgPT4gZmQubmFtZSA9PT0gZikpO1xuXG4gIC8vIGRlbGV0ZVxuICBuZXdUZXh0TGFiZWwgPSBuZXdUZXh0TGFiZWwuZmlsdGVyKHRsID0+IHRsLmZpZWxkICYmICFkZWxldGVGaWVsZHMuaW5jbHVkZXModGwuZmllbGQubmFtZSkpO1xuICBuZXdUZXh0TGFiZWwgPSAhbmV3VGV4dExhYmVsLmxlbmd0aCA/IFtERUZBVUxUX1RFWFRfTEFCRUxdIDogbmV3VGV4dExhYmVsO1xuXG4gIC8vIGFkZFxuICBuZXdUZXh0TGFiZWwgPSBbXG4gICAgLi4ubmV3VGV4dExhYmVsLmZpbHRlcih0bCA9PiB0bC5maWVsZCksXG4gICAgLi4uYWRkRmllbGRzLm1hcChhZiA9PiAoe1xuICAgICAgLi4uREVGQVVMVF9URVhUX0xBQkVMLFxuICAgICAgZmllbGQ6IGFmXG4gICAgfSkpXG4gIF07XG5cbiAgcmV0dXJuIG5ld1RleHRMYWJlbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVGV4dExhYmVsUHJvcEFuZFZhbHVlKGlkeCwgcHJvcCwgdmFsdWUsIHRleHRMYWJlbCkge1xuICBpZiAoIXRleHRMYWJlbFtpZHhdLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgcmV0dXJuIHRleHRMYWJlbDtcbiAgfVxuXG4gIGxldCBuZXdUZXh0TGFiZWwgPSB0ZXh0TGFiZWwuc2xpY2UoKTtcblxuICBpZiAocHJvcCAmJiAodmFsdWUgfHwgdGV4dExhYmVsLmxlbmd0aCA9PT0gMSkpIHtcbiAgICBuZXdUZXh0TGFiZWwgPSB0ZXh0TGFiZWwubWFwKCh0bCwgaSkgPT4gKGkgPT09IGlkeCA/IHsuLi50bCwgW3Byb3BdOiB2YWx1ZX0gOiB0bCkpO1xuICB9IGVsc2UgaWYgKHByb3AgPT09ICdmaWVsZCcgJiYgdmFsdWUgPT09IG51bGwgJiYgdGV4dExhYmVsLmxlbmd0aCA+IDEpIHtcbiAgICAvLyByZW1vdmUgbGFiZWwgd2hlbiBmaWVsZCB2YWx1ZSBpcyBzZXQgdG8gbnVsbFxuICAgIG5ld1RleHRMYWJlbC5zcGxpY2UoaWR4LCAxKTtcbiAgfVxuXG4gIHJldHVybiBuZXdUZXh0TGFiZWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXllclRleHRMYWJlbENoYW5nZVVwZGF0ZXIoc3RhdGUsIGFjdGlvbikge1xuICBjb25zdCB7b2xkTGF5ZXIsIGlkeCwgcHJvcCwgdmFsdWV9ID0gYWN0aW9uO1xuICBjb25zdCB7dGV4dExhYmVsfSA9IG9sZExheWVyLmNvbmZpZztcblxuICBsZXQgbmV3VGV4dExhYmVsID0gdGV4dExhYmVsLnNsaWNlKCk7XG4gIGlmICghdGV4dExhYmVsW2lkeF0gJiYgaWR4ID09PSB0ZXh0TGFiZWwubGVuZ3RoKSB7XG4gICAgLy8gaWYgaWR4IGlzIHNldCB0byBsZW5ndGgsIGFkZCBlbXB0eSB0ZXh0IGxhYmVsXG4gICAgbmV3VGV4dExhYmVsID0gWy4uLnRleHRMYWJlbCwgREVGQVVMVF9URVhUX0xBQkVMXTtcbiAgfVxuXG4gIGlmIChpZHggPT09ICdhbGwnICYmIHByb3AgPT09ICdmaWVsZHMnKSB7XG4gICAgbmV3VGV4dExhYmVsID0gYWRkT3JSZW1vdmVUZXh0TGFiZWxzKHZhbHVlLCB0ZXh0TGFiZWwpO1xuICB9IGVsc2Uge1xuICAgIG5ld1RleHRMYWJlbCA9IHVwZGF0ZVRleHRMYWJlbFByb3BBbmRWYWx1ZShpZHgsIHByb3AsIHZhbHVlLCBuZXdUZXh0TGFiZWwpO1xuICB9XG5cbiAgLy8gdXBkYXRlIHRleHQgbGFiZWwgcHJvcCBhbmQgdmFsdWVcbiAgcmV0dXJuIGxheWVyQ29uZmlnQ2hhbmdlVXBkYXRlcihzdGF0ZSwge1xuICAgIG9sZExheWVyLFxuICAgIG5ld0NvbmZpZzoge3RleHRMYWJlbDogbmV3VGV4dExhYmVsfVxuICB9KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgbGF5ZXIgdHlwZS4gUHJldmlld3MgbGF5ZXIgY29uZmlnIHdpbGwgYmUgY29waWVkIGlmIGFwcGxpY2FibGUuXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLm9sZExheWVyIGxheWVyIHRvIGJlIHVwZGF0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24ubmV3VHlwZSBuZXcgdHlwZVxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllclR5cGVDaGFuZ2VVcGRhdGVyKHN0YXRlLCBhY3Rpb24pIHtcbiAgY29uc3Qge29sZExheWVyLCBuZXdUeXBlfSA9IGFjdGlvbjtcbiAgaWYgKCFvbGRMYXllcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCBvbGRJZCA9IG9sZExheWVyLmlkO1xuICBjb25zdCBpZHggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkSWQpO1xuXG4gIGlmICghc3RhdGUubGF5ZXJDbGFzc2VzW25ld1R5cGVdKSB7XG4gICAgQ29uc29sZS5lcnJvcihgJHtuZXdUeXBlfSBpcyBub3QgYSB2YWxpZCBsYXllciB0eXBlYCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgLy8gZ2V0IGEgbWludCBsYXllciwgd2l0aCBuZXcgaWQgYW5kIHR5cGVcbiAgLy8gYmVjYXVzZSBkZWNrLmdsIHVzZXMgaWQgdG8gbWF0Y2ggYmV0d2VlbiBuZXcgYW5kIG9sZCBsYXllci5cbiAgLy8gSWYgdHlwZSBoYXMgY2hhbmdlZCBidXQgaWQgaXMgdGhlIHNhbWUsIGl0IHdpbGwgYnJlYWtcbiAgY29uc3QgbmV3TGF5ZXIgPSBuZXcgc3RhdGUubGF5ZXJDbGFzc2VzW25ld1R5cGVdKCk7XG5cbiAgbmV3TGF5ZXIuYXNzaWduQ29uZmlnVG9MYXllcihvbGRMYXllci5jb25maWcsIG9sZExheWVyLnZpc0NvbmZpZ1NldHRpbmdzKTtcblxuICAvLyBpZiAobmV3TGF5ZXIuY29uZmlnLmRhdGFJZCkge1xuICAvLyAgIGNvbnN0IGRhdGFzZXQgPSBzdGF0ZS5kYXRhc2V0c1tuZXdMYXllci5jb25maWcuZGF0YUlkXTtcbiAgLy8gICBuZXdMYXllci51cGRhdGVMYXllckRvbWFpbihkYXRhc2V0KTtcbiAgLy8gfVxuICBuZXdMYXllci51cGRhdGVMYXllckRvbWFpbihzdGF0ZS5kYXRhc2V0cyk7XG4gIGNvbnN0IHtsYXllckRhdGEsIGxheWVyfSA9IGNhbGN1bGF0ZUxheWVyRGF0YShuZXdMYXllciwgc3RhdGUpO1xuICBsZXQgbmV3U3RhdGUgPSB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEoc3RhdGUsIHtsYXllckRhdGEsIGxheWVyLCBpZHh9KTtcblxuICBpZiAobGF5ZXIuY29uZmlnLmFuaW1hdGlvbi5lbmFibGVkIHx8IG9sZExheWVyLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlZCkge1xuICAgIG5ld1N0YXRlID0gdXBkYXRlQW5pbWF0aW9uRG9tYWluKG5ld1N0YXRlKTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBzcGxpdE1hcCBsYXllciBpZFxuICBpZiAoc3RhdGUuc3BsaXRNYXBzLmxlbmd0aCkge1xuICAgIG5ld1N0YXRlID0ge1xuICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICBzcGxpdE1hcHM6IG5ld1N0YXRlLnNwbGl0TWFwcy5tYXAoc2V0dGluZ3MgPT4ge1xuICAgICAgICBjb25zdCB7W29sZElkXTogb2xkTGF5ZXJNYXAsIC4uLm90aGVyTGF5ZXJzfSA9IHNldHRpbmdzLmxheWVycztcbiAgICAgICAgcmV0dXJuIG9sZElkIGluIHNldHRpbmdzLmxheWVyc1xuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgICAgICAgbGF5ZXJzOiB7XG4gICAgICAgICAgICAgICAgLi4ub3RoZXJMYXllcnMsXG4gICAgICAgICAgICAgICAgW2xheWVyLmlkXTogb2xkTGF5ZXJNYXBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogc2V0dGluZ3M7XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbi8qKlxuICogVXBkYXRlIGxheWVyIHZpc3VhbCBjaGFubmVsXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLm9sZExheWVyIGxheWVyIHRvIGJlIHVwZGF0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24ubmV3Q29uZmlnIG5ldyB2aXN1YWwgY2hhbm5lbCBjb25maWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24uY2hhbm5lbCBjaGFubmVsIHRvIGJlIHVwZGF0ZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJWaXN1YWxDaGFubmVsQ2hhbmdlVXBkYXRlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIGNvbnN0IHtvbGRMYXllciwgbmV3Q29uZmlnLCBjaGFubmVsfSA9IGFjdGlvbjtcbiAgY29uc3QgZGF0YXNldCA9IHN0YXRlLmRhdGFzZXRzW29sZExheWVyLmNvbmZpZy5kYXRhSWRdO1xuXG4gIGNvbnN0IGlkeCA9IHN0YXRlLmxheWVycy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBvbGRMYXllci5pZCk7XG4gIGNvbnN0IG5ld0xheWVyID0gb2xkTGF5ZXIudXBkYXRlTGF5ZXJDb25maWcobmV3Q29uZmlnKTtcblxuICBuZXdMYXllci51cGRhdGVMYXllclZpc3VhbENoYW5uZWwoZGF0YXNldCwgY2hhbm5lbCk7XG5cbiAgY29uc3Qgb2xkTGF5ZXJEYXRhID0gc3RhdGUubGF5ZXJEYXRhW2lkeF07XG4gIGNvbnN0IHtsYXllckRhdGEsIGxheWVyfSA9IGNhbGN1bGF0ZUxheWVyRGF0YShuZXdMYXllciwgc3RhdGUsIG9sZExheWVyRGF0YSk7XG5cbiAgcmV0dXJuIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShzdGF0ZSwge2xheWVyRGF0YSwgbGF5ZXIsIGlkeH0pO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBsYXllciBgdmlzQ29uZmlnYFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5vbGRMYXllciBsYXllciB0byBiZSB1cGRhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLm5ld1Zpc0NvbmZpZyBuZXcgdmlzQ29uZmlnIGFzIGEga2V5IHZhbHVlIG1hcDogZS5nLiBge29wYWNpdHk6IDAuOH1gXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxheWVyVmlzQ29uZmlnQ2hhbmdlVXBkYXRlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIGNvbnN0IHtvbGRMYXllcn0gPSBhY3Rpb247XG4gIGNvbnN0IGlkeCA9IHN0YXRlLmxheWVycy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBvbGRMYXllci5pZCk7XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMoYWN0aW9uLm5ld1Zpc0NvbmZpZyk7XG4gIGNvbnN0IG5ld1Zpc0NvbmZpZyA9IHtcbiAgICAuLi5vbGRMYXllci5jb25maWcudmlzQ29uZmlnLFxuICAgIC4uLmFjdGlvbi5uZXdWaXNDb25maWdcbiAgfTtcblxuICBjb25zdCBuZXdMYXllciA9IG9sZExheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHt2aXNDb25maWc6IG5ld1Zpc0NvbmZpZ30pO1xuXG4gIGlmIChuZXdMYXllci5zaG91bGRDYWxjdWxhdGVMYXllckRhdGEocHJvcHMpKSB7XG4gICAgY29uc3Qgb2xkTGF5ZXJEYXRhID0gc3RhdGUubGF5ZXJEYXRhW2lkeF07XG4gICAgY29uc3Qge2xheWVyRGF0YSwgbGF5ZXJ9ID0gY2FsY3VsYXRlTGF5ZXJEYXRhKG5ld0xheWVyLCBzdGF0ZSwgb2xkTGF5ZXJEYXRhKTtcbiAgICByZXR1cm4gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhKHN0YXRlLCB7bGF5ZXJEYXRhLCBsYXllciwgaWR4fSk7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhKHN0YXRlLCB7bGF5ZXI6IG5ld0xheWVyLCBpZHh9KTtcbn1cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4vKipcbiAqIFVwZGF0ZSBgaW50ZXJhY3Rpb25Db25maWdgXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLmNvbmZpZyBuZXcgY29uZmlnIGFzIGtleSB2YWx1ZSBtYXA6IGB7dG9vbHRpcDoge2VuYWJsZWQ6IHRydWV9fWBcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJhY3Rpb25Db25maWdDaGFuZ2VVcGRhdGVyKHN0YXRlLCBhY3Rpb24pIHtcbiAgY29uc3Qge2NvbmZpZ30gPSBhY3Rpb247XG5cbiAgY29uc3QgaW50ZXJhY3Rpb25Db25maWcgPSB7XG4gICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Db25maWcsXG4gICAgLi4ue1tjb25maWcuaWRdOiBjb25maWd9XG4gIH07XG5cbiAgLy8gRG9uJ3QgZW5hYmxlIHRvb2x0aXAgYW5kIGJydXNoIGF0IHRoZSBzYW1lIHRpbWVcbiAgLy8gYnV0IGNvb3JkaW5hdGVzIGNhbiBiZSBzaG93biBhdCBhbGwgdGltZVxuICBjb25zdCBjb250cmFkaWN0ID0gWydicnVzaCcsICd0b29sdGlwJ107XG5cbiAgaWYgKFxuICAgIGNvbnRyYWRpY3QuaW5jbHVkZXMoY29uZmlnLmlkKSAmJlxuICAgIGNvbmZpZy5lbmFibGVkICYmXG4gICAgIXN0YXRlLmludGVyYWN0aW9uQ29uZmlnW2NvbmZpZy5pZF0uZW5hYmxlZFxuICApIHtcbiAgICAvLyBvbmx5IGVuYWJsZSBvbmUgaW50ZXJhY3Rpb24gYXQgYSB0aW1lXG4gICAgY29udHJhZGljdC5mb3JFYWNoKGsgPT4ge1xuICAgICAgaWYgKGsgIT09IGNvbmZpZy5pZCkge1xuICAgICAgICBpbnRlcmFjdGlvbkNvbmZpZ1trXSA9IHsuLi5pbnRlcmFjdGlvbkNvbmZpZ1trXSwgZW5hYmxlZDogZmFsc2V9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBpbnRlcmFjdGlvbkNvbmZpZ1xuICB9O1xufVxuXG4vKipcbiAqIFVwZGF0ZSBmaWx0ZXIgcHJvcGVydHlcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBhY3Rpb24uaWR4IGBpZHhgIG9mIGZpbHRlciB0byBiZSB1cGRhdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uLnByb3AgYHByb3BgIG9mIGZpbHRlciwgZSxnLCBgZGF0YUlkYCwgYG5hbWVgLCBgdmFsdWVgXG4gKiBAcGFyYW0geyp9IGFjdGlvbi52YWx1ZSBuZXcgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0SWQgdXNlZCB3aGVuIHVwZGF0aW5nIGEgcHJvcCAoZGF0YUlkLCBuYW1lKSB0aGF0IGNhbiBiZSBsaW5rZWQgdG8gbXVsdGlwbGUgZGF0YXNldHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RmlsdGVyVXBkYXRlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIGNvbnN0IHtpZHgsIHByb3AsIHZhbHVlLCB2YWx1ZUluZGV4ID0gMH0gPSBhY3Rpb247XG5cbiAgY29uc3Qgb2xkRmlsdGVyID0gc3RhdGUuZmlsdGVyc1tpZHhdO1xuICBsZXQgbmV3RmlsdGVyID0gc2V0KFtwcm9wXSwgdmFsdWUsIG9sZEZpbHRlcik7XG4gIGxldCBuZXdTdGF0ZSA9IHN0YXRlO1xuXG4gIGNvbnN0IHtkYXRhSWR9ID0gbmV3RmlsdGVyO1xuXG4gIC8vIEVuc3VyaW5nIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgbGV0IGRhdGFzZXRJZHMgPSB0b0FycmF5KGRhdGFJZCk7XG5cbiAgc3dpdGNoIChwcm9wKSB7XG4gICAgLy8gVE9ETzogTmV4dCBQUiBmb3IgVUkgaWYgd2UgdXBkYXRlIGRhdGFJZCwgd2UgbmVlZCB0byBjb25zaWRlciB0d28gY2FzZXM6XG4gICAgLy8gMS4gZGF0YUlkIGlzIGVtcHR5OiBjcmVhdGUgYSBkZWZhdWx0IGZpbHRlclxuICAgIC8vIDIuIEFkZCBhIG5ldyBkYXRhc2V0IGlkXG4gICAgY2FzZSBGSUxURVJfVVBEQVRFUl9QUk9QUy5kYXRhSWQ6XG4gICAgICAvLyBpZiB0cnlpbmcgdG8gdXBkYXRlIGZpbHRlciBkYXRhSWQuIGNyZWF0ZSBhbiBlbXB0eSBuZXcgZmlsdGVyXG4gICAgICBuZXdGaWx0ZXIgPSB1cGRhdGVGaWx0ZXJEYXRhSWQoZGF0YUlkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBGSUxURVJfVVBEQVRFUl9QUk9QUy5uYW1lOlxuICAgICAgLy8gd2UgYXJlIHN1cHBvcnRpbmcgdGhlIGN1cnJlbnQgZnVuY3Rpb25hbGl0eVxuICAgICAgLy8gVE9ETzogTmV4dCBQUiBmb3IgVUkgZmlsdGVyIG5hbWUgd2lsbCBvbmx5IHVwZGF0ZSBmaWx0ZXIgbmFtZSBidXQgaXQgd29uJ3QgaGF2ZSBzaWRlIGVmZmVjdHNcbiAgICAgIC8vIHdlIGFyZSBnb25uYSB1c2UgcGFpciBvZiBkYXRhc2V0cyBhbmQgZmllbGRJZHggdG8gdXBkYXRlIHRoZSBmaWx0ZXJcbiAgICAgIGNvbnN0IGRhdGFzZXRJZCA9IG5ld0ZpbHRlci5kYXRhSWRbdmFsdWVJbmRleF07XG4gICAgICBjb25zdCB7ZmlsdGVyOiB1cGRhdGVkRmlsdGVyLCBkYXRhc2V0OiBuZXdEYXRhc2V0fSA9IGFwcGx5RmlsdGVyRmllbGROYW1lKFxuICAgICAgICBuZXdGaWx0ZXIsXG4gICAgICAgIHN0YXRlLmRhdGFzZXRzW2RhdGFzZXRJZF0sXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB2YWx1ZUluZGV4LFxuICAgICAgICB7bWVyZ2VEb21haW46IGZhbHNlfVxuICAgICAgKTtcbiAgICAgIGlmICghdXBkYXRlZEZpbHRlcikge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIG5ld0ZpbHRlciA9IHVwZGF0ZWRGaWx0ZXI7XG5cbiAgICAgIGlmIChuZXdGaWx0ZXIuZ3B1KSB7XG4gICAgICAgIG5ld0ZpbHRlciA9IHNldEZpbHRlckdwdU1vZGUobmV3RmlsdGVyLCBzdGF0ZS5maWx0ZXJzKTtcbiAgICAgICAgbmV3RmlsdGVyID0gYXNzaWduR3B1Q2hhbm5lbChuZXdGaWx0ZXIsIHN0YXRlLmZpbHRlcnMpO1xuICAgICAgfVxuXG4gICAgICBuZXdTdGF0ZSA9IHNldChbJ2RhdGFzZXRzJywgZGF0YXNldElkXSwgbmV3RGF0YXNldCwgc3RhdGUpO1xuXG4gICAgICAvLyBvbmx5IGZpbHRlciB0aGUgY3VycmVudCBkYXRhc2V0XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZJTFRFUl9VUERBVEVSX1BST1BTLmxheWVySWQ6XG4gICAgICAvLyBXZSBuZWVkIHRvIHVwZGF0ZSBvbmx5IGRhdGFzZXRJZC9zIGlmIHdlIGhhdmUgYWRkZWQvcmVtb3ZlZCBsYXllcnNcbiAgICAgIC8vIC0gY2hlY2sgZm9yIGxheWVySWQgY2hhbmdlcyAoWE9SIHdvcmtzIGJlY2F1c2Ugb2Ygc3RyaW5nIHZhbHVlcylcbiAgICAgIC8vIGlmIG5vIGRpZmZlcmVuY2VzIGJldHdlZW4gbGF5ZXJJZHMsIGRvbid0IGRvIGFueSBmaWx0ZXJpbmdcbiAgICAgIGNvbnN0IGxheWVySWREaWZmZXJlbmNlID0geG9yKG5ld0ZpbHRlci5sYXllcklkLCBvbGRGaWx0ZXIubGF5ZXJJZCk7XG5cbiAgICAgIGNvbnN0IGxheWVyRGF0YUlkcyA9IHVuaXEoXG4gICAgICAgIGxheWVySWREaWZmZXJlbmNlXG4gICAgICAgICAgLm1hcChsaWQgPT5cbiAgICAgICAgICAgIGdldChcbiAgICAgICAgICAgICAgc3RhdGUubGF5ZXJzLmZpbmQobCA9PiBsLmlkID09PSBsaWQpLFxuICAgICAgICAgICAgICBbJ2NvbmZpZycsICdkYXRhSWQnXVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgICAuZmlsdGVyKGQgPT4gZClcbiAgICAgICk7XG5cbiAgICAgIC8vIG9ubHkgZmlsdGVyIGRhdGFzZXRzSWRzXG4gICAgICBkYXRhc2V0SWRzID0gbGF5ZXJEYXRhSWRzO1xuXG4gICAgICAvLyBVcGRhdGUgbmV3RmlsdGVyIGRhdGFJZHNcbiAgICAgIGNvbnN0IG5ld0RhdGFJZHMgPSB1bmlxKFxuICAgICAgICBuZXdGaWx0ZXIubGF5ZXJJZFxuICAgICAgICAgIC5tYXAobGlkID0+XG4gICAgICAgICAgICBnZXQoXG4gICAgICAgICAgICAgIHN0YXRlLmxheWVycy5maW5kKGwgPT4gbC5pZCA9PT0gbGlkKSxcbiAgICAgICAgICAgICAgWydjb25maWcnLCAnZGF0YUlkJ11cbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICAgLmZpbHRlcihkID0+IGQpXG4gICAgICApO1xuXG4gICAgICBuZXdGaWx0ZXIgPSB7XG4gICAgICAgIC4uLm5ld0ZpbHRlcixcbiAgICAgICAgZGF0YUlkOiBuZXdEYXRhSWRzXG4gICAgICB9O1xuXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBjb25zdCBlbmxhcmdlZEZpbHRlciA9IHN0YXRlLmZpbHRlcnMuZmluZChmID0+IGYuZW5sYXJnZWQpO1xuXG4gIGlmIChlbmxhcmdlZEZpbHRlciAmJiBlbmxhcmdlZEZpbHRlci5pZCAhPT0gbmV3RmlsdGVyLmlkKSB7XG4gICAgLy8gdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGVubGFyZ2VkIGZpbHRlclxuICAgIG5ld0ZpbHRlci5lbmxhcmdlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gc2F2ZSBuZXcgZmlsdGVycyB0byBuZXdTdGF0ZVxuICBuZXdTdGF0ZSA9IHNldChbJ2ZpbHRlcnMnLCBpZHhdLCBuZXdGaWx0ZXIsIG5ld1N0YXRlKTtcblxuICAvLyBpZiB3ZSBhcmUgY3VycmVudGx5IHNldHRpbmcgYSBwcm9wIHRoYXQgb25seSByZXF1aXJlcyB0byBmaWx0ZXIgdGhlIGN1cnJlbnRcbiAgLy8gZGF0YXNldCB3ZSB3aWxsIHBhc3Mgb25seSB0aGUgY3VycmVudCBkYXRhc2V0IHRvIGFwcGx5RmlsdGVyc1RvRGF0YXNldHMgYW5kXG4gIC8vIHVwZGF0ZUFsbExheWVyRG9tYWluRGF0YSBvdGhlcndpc2Ugd2UgcGFzcyB0aGUgYWxsIGxpc3Qgb2YgZGF0YXNldHMgYXMgZGVmaW5lZCBpbiBkYXRhSWRcbiAgY29uc3QgZGF0YXNldElkc1RvRmlsdGVyID0gTElNSVRFRF9GSUxURVJfRUZGRUNUX1BST1BTW3Byb3BdXG4gICAgPyBbZGF0YXNldElkc1t2YWx1ZUluZGV4XV1cbiAgICA6IGRhdGFzZXRJZHM7XG5cbiAgLy8gZmlsdGVyIGRhdGFcbiAgY29uc3QgZmlsdGVyZWREYXRhc2V0cyA9IGFwcGx5RmlsdGVyc1RvRGF0YXNldHMoXG4gICAgZGF0YXNldElkc1RvRmlsdGVyLFxuICAgIG5ld1N0YXRlLmRhdGFzZXRzLFxuICAgIG5ld1N0YXRlLmZpbHRlcnMsXG4gICAgbmV3U3RhdGUubGF5ZXJzXG4gICk7XG5cbiAgbmV3U3RhdGUgPSBzZXQoWydkYXRhc2V0cyddLCBmaWx0ZXJlZERhdGFzZXRzLCBuZXdTdGF0ZSk7XG4gIC8vIGRhdGFJZCBpcyBhbiBhcnJheVxuICAvLyBwYXNzIG9ubHkgdGhlIGRhdGFzZXQgd2UgbmVlZCB0byB1cGRhdGVcbiAgbmV3U3RhdGUgPSB1cGRhdGVBbGxMYXllckRvbWFpbkRhdGEobmV3U3RhdGUsIGRhdGFzZXRJZHNUb0ZpbHRlciwgbmV3RmlsdGVyKTtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbi8qKlxuICogU2V0IHRoZSBwcm9wZXJ0eSBvZiBhIGZpbHRlciBwbG90XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYWN0aW9uLmlkeFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5uZXdQcm9wIGtleSB2YWx1ZSBtYXBwaW5nIG9mIG5ldyBwcm9wIGB7eUF4aXM6ICdoaXN0b2dyYW0nfWBcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3Qgc2V0RmlsdGVyUGxvdFVwZGF0ZXIgPSAoc3RhdGUsIHtpZHgsIG5ld1Byb3B9KSA9PiB7XG4gIGxldCBuZXdGaWx0ZXIgPSB7Li4uc3RhdGUuZmlsdGVyc1tpZHhdLCAuLi5uZXdQcm9wfTtcbiAgY29uc3QgcHJvcCA9IE9iamVjdC5rZXlzKG5ld1Byb3ApWzBdO1xuICBpZiAocHJvcCA9PT0gJ3lBeGlzJykge1xuICAgIGNvbnN0IHBsb3RUeXBlID0gZ2V0RGVmYXVsdEZpbHRlclBsb3RUeXBlKG5ld0ZpbHRlcik7XG5cbiAgICBpZiAocGxvdFR5cGUpIHtcbiAgICAgIG5ld0ZpbHRlciA9IHtcbiAgICAgICAgLi4ubmV3RmlsdGVyLFxuICAgICAgICAuLi5nZXRGaWx0ZXJQbG90KHsuLi5uZXdGaWx0ZXIsIHBsb3RUeXBlfSwgc3RhdGUuZGF0YXNldHNbbmV3RmlsdGVyLmRhdGFJZF0uYWxsRGF0YSksXG4gICAgICAgIHBsb3RUeXBlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZmlsdGVyczogc3RhdGUuZmlsdGVycy5tYXAoKGYsIGkpID0+IChpID09PSBpZHggPyBuZXdGaWx0ZXIgOiBmKSlcbiAgfTtcbn07XG5cbi8qKlxuICogQWRkIGEgbmV3IGZpbHRlclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbi5kYXRhSWQgZGF0YXNldCBgaWRgIHRoaXMgbmV3IGZpbHRlciBpcyBhc3NvY2lhdGVkIHdpdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgYWRkRmlsdGVyVXBkYXRlciA9IChzdGF0ZSwgYWN0aW9uKSA9PlxuICAhYWN0aW9uLmRhdGFJZFxuICAgID8gc3RhdGVcbiAgICA6IHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGZpbHRlcnM6IFsuLi5zdGF0ZS5maWx0ZXJzLCBnZXREZWZhdWx0RmlsdGVyKGFjdGlvbi5kYXRhSWQpXVxuICAgICAgfTtcblxuLyoqXG4gKiBTZXQgbGF5ZXIgY29sb3IgcGFsZXR0ZSB1aSBzdGF0ZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5wcm9wXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLm5ld0NvbmZpZ1xuICovXG5leHBvcnQgY29uc3QgbGF5ZXJDb2xvclVJQ2hhbmdlVXBkYXRlciA9IChzdGF0ZSwge29sZExheWVyLCBwcm9wLCBuZXdDb25maWd9KSA9PiB7XG4gIGNvbnN0IG5ld0xheWVyID0gb2xkTGF5ZXIudXBkYXRlTGF5ZXJDb2xvclVJKHByb3AsIG5ld0NvbmZpZyk7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBzdGF0ZS5sYXllcnMubWFwKGwgPT4gKGwuaWQgPT09IG9sZExheWVyLmlkID8gbmV3TGF5ZXIgOiBsKSlcbiAgfTtcbn07XG5cbi8qKlxuICogU3RhcnQgYW5kIGVuZCBmaWx0ZXIgYW5pbWF0aW9uXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYWN0aW9uLmlkeCBpZHggb2YgZmlsdGVyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUZpbHRlckFuaW1hdGlvblVwZGF0ZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGZpbHRlcnM6IHN0YXRlLmZpbHRlcnMubWFwKChmLCBpKSA9PiAoaSA9PT0gYWN0aW9uLmlkeCA/IHsuLi5mLCBpc0FuaW1hdGluZzogIWYuaXNBbmltYXRpbmd9IDogZikpXG59KTtcblxuLyoqXG4gKiBDaGFuZ2UgZmlsdGVyIGFuaW1hdGlvbiBzcGVlZFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIGFjdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGFjdGlvbi5pZHggIGBpZHhgIG9mIGZpbHRlclxuICogQHBhcmFtIHtOdW1iZXJ9IGFjdGlvbi5zcGVlZCBgc3BlZWRgIHRvIGNoYW5nZSBpdCB0by4gYHNwZWVkYCBpcyBhIG11bHRpcGxpZXJcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdXBkYXRlRmlsdGVyQW5pbWF0aW9uU3BlZWRVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+ICh7XG4gIC4uLnN0YXRlLFxuICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcCgoZiwgaSkgPT4gKGkgPT09IGFjdGlvbi5pZHggPyB7Li4uZiwgc3BlZWQ6IGFjdGlvbi5zcGVlZH0gOiBmKSlcbn0pO1xuXG4vKipcbiAqIFJlc2V0IGFuaW1hdGlvbiBjb25maWcgY3VycmVudCB0aW1lIHRvIGEgc3BlY2lmaWVkIHZhbHVlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYWN0aW9uLnZhbHVlIHRoZSB2YWx1ZSBjdXJyZW50IHRpbWUgd2lsbCBiZSBzZXQgdG9cbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICpcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUFuaW1hdGlvblRpbWVVcGRhdGVyID0gKHN0YXRlLCB7dmFsdWV9KSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgYW5pbWF0aW9uQ29uZmlnOiB7XG4gICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgIGN1cnJlbnRUaW1lOiB2YWx1ZVxuICB9XG59KTtcblxuLyoqXG4gKiBVcGRhdGUgYW5pbWF0aW9uIHNwZWVkIHdpdGggdGhlIHZlcnRpY2FsIHNwZWVkIHNsaWRlclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIGFjdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGFjdGlvbi5zcGVlZCB0aGUgdXBkYXRlZCBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVMYXllckFuaW1hdGlvblNwZWVkVXBkYXRlciA9IChzdGF0ZSwge3NwZWVkfSkgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGFuaW1hdGlvbkNvbmZpZzoge1xuICAgICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgICAgc3BlZWRcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFNob3cgbGFyZ2VyIHRpbWUgZmlsdGVyIGF0IGJvdHRvbSBmb3IgdGltZSBwbGF5YmFjayAoYXBwbHkgdG8gdGltZSBmaWx0ZXIgb25seSlcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBhY3Rpb24uaWR4IGluZGV4IG9mIGZpbHRlciB0byBlbmxhcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGVubGFyZ2VGaWx0ZXJVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgY29uc3QgaXNFbmxhcmdlZCA9IHN0YXRlLmZpbHRlcnNbYWN0aW9uLmlkeF0uZW5sYXJnZWQ7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcCgoZiwgaSkgPT4ge1xuICAgICAgZi5lbmxhcmdlZCA9ICFpc0VubGFyZ2VkICYmIGkgPT09IGFjdGlvbi5pZHg7XG4gICAgICByZXR1cm4gZjtcbiAgICB9KVxuICB9O1xufTtcblxuLyoqXG4gKiBUb2dnbGVzIGZpbHRlciBmZWF0dXJlIHZpc2liaWxpdHlcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBhY3Rpb24uaWR4IGluZGV4IG9mIGZpbHRlciB0byBlbmxhcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUZpbHRlckZlYXR1cmVVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgY29uc3QgZmlsdGVyID0gc3RhdGUuZmlsdGVyc1thY3Rpb24uaWR4XTtcbiAgY29uc3QgaXNWaXNpYmxlID0gZ2V0KGZpbHRlciwgWyd2YWx1ZScsICdwcm9wZXJ0aWVzJywgJ2lzVmlzaWJsZSddKTtcbiAgY29uc3QgbmV3RmlsdGVyID0ge1xuICAgIC4uLmZpbHRlcixcbiAgICB2YWx1ZTogZmVhdHVyZVRvRmlsdGVyVmFsdWUoZmlsdGVyLnZhbHVlLCBmaWx0ZXIuaWQsIHtcbiAgICAgIGlzVmlzaWJsZTogIWlzVmlzaWJsZVxuICAgIH0pXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBmaWx0ZXJzOiBPYmplY3QuYXNzaWduKFtdLmNvbmNhdChzdGF0ZS5maWx0ZXJzKSwge1thY3Rpb24uaWR4XTogbmV3RmlsdGVyfSlcbiAgfTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgZmlsdGVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYWN0aW9uLmlkeCBpbmRleCBvZiBmaWx0ZXIgdG8gYiBlIHJlbW92ZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRmlsdGVyVXBkYXRlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIGNvbnN0IHtpZHh9ID0gYWN0aW9uO1xuICBjb25zdCB7ZGF0YUlkLCBpZH0gPSBzdGF0ZS5maWx0ZXJzW2lkeF07XG5cbiAgY29uc3QgbmV3RmlsdGVycyA9IFtcbiAgICAuLi5zdGF0ZS5maWx0ZXJzLnNsaWNlKDAsIGlkeCksXG4gICAgLi4uc3RhdGUuZmlsdGVycy5zbGljZShpZHggKyAxLCBzdGF0ZS5maWx0ZXJzLmxlbmd0aClcbiAgXTtcblxuICBjb25zdCBmaWx0ZXJlZERhdGFzZXRzID0gYXBwbHlGaWx0ZXJzVG9EYXRhc2V0cyhkYXRhSWQsIHN0YXRlLmRhdGFzZXRzLCBuZXdGaWx0ZXJzLCBzdGF0ZS5sYXllcnMpO1xuICBjb25zdCBuZXdFZGl0b3IgPVxuICAgIGdldEZpbHRlcklkSW5GZWF0dXJlKHN0YXRlLmVkaXRvci5zZWxlY3RlZEZlYXR1cmUpID09PSBpZFxuICAgICAgPyB7XG4gICAgICAgICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgICAgICAgIHNlbGVjdGVkRmVhdHVyZTogbnVsbFxuICAgICAgICB9XG4gICAgICA6IHN0YXRlLmVkaXRvcjtcblxuICBsZXQgbmV3U3RhdGUgPSBzZXQoWydmaWx0ZXJzJ10sIG5ld0ZpbHRlcnMsIHN0YXRlKTtcbiAgbmV3U3RhdGUgPSBzZXQoWydkYXRhc2V0cyddLCBmaWx0ZXJlZERhdGFzZXRzLCBuZXdTdGF0ZSk7XG4gIG5ld1N0YXRlID0gc2V0KFsnZWRpdG9yJ10sIG5ld0VkaXRvciwgbmV3U3RhdGUpO1xuXG4gIHJldHVybiB1cGRhdGVBbGxMYXllckRvbWFpbkRhdGEobmV3U3RhdGUsIGRhdGFJZCk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG5ldyBsYXllclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5wcm9wcyAtIG5ldyBsYXllciBwcm9wc1xuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRMYXllclVwZGF0ZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICBjb25zdCBkZWZhdWx0RGF0YXNldCA9IE9iamVjdC5rZXlzKHN0YXRlLmRhdGFzZXRzKVswXTtcbiAgY29uc3QgbmV3TGF5ZXIgPSBuZXcgTGF5ZXIoe1xuICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICBpc0NvbmZpZ0FjdGl2ZTogdHJ1ZSxcbiAgICBkYXRhSWQ6IGRlZmF1bHREYXRhc2V0LFxuICAgIC4uLmFjdGlvbi5wcm9wc1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogWy4uLnN0YXRlLmxheWVycywgbmV3TGF5ZXJdLFxuICAgIGxheWVyRGF0YTogWy4uLnN0YXRlLmxheWVyRGF0YSwge31dLFxuICAgIGxheWVyT3JkZXI6IFsuLi5zdGF0ZS5sYXllck9yZGVyLCBzdGF0ZS5sYXllck9yZGVyLmxlbmd0aF0sXG4gICAgc3BsaXRNYXBzOiBhZGROZXdMYXllcnNUb1NwbGl0TWFwKHN0YXRlLnNwbGl0TWFwcywgbmV3TGF5ZXIpXG4gIH07XG59O1xuXG4vKipcbiAqIHJlbW92ZSBsYXllclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIGFjdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGFjdGlvbi5pZHggaW5kZXggb2YgbGF5ZXIgdG8gYiBlIHJlbW92ZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlTGF5ZXJVcGRhdGVyID0gKHN0YXRlLCB7aWR4fSkgPT4ge1xuICBjb25zdCB7bGF5ZXJzLCBsYXllckRhdGEsIGNsaWNrZWQsIGhvdmVySW5mb30gPSBzdGF0ZTtcbiAgY29uc3QgbGF5ZXJUb1JlbW92ZSA9IHN0YXRlLmxheWVyc1tpZHhdO1xuICBjb25zdCBuZXdNYXBzID0gcmVtb3ZlTGF5ZXJGcm9tU3BsaXRNYXBzKHN0YXRlLnNwbGl0TWFwcywgbGF5ZXJUb1JlbW92ZSk7XG5cbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBbLi4ubGF5ZXJzLnNsaWNlKDAsIGlkeCksIC4uLmxheWVycy5zbGljZShpZHggKyAxLCBsYXllcnMubGVuZ3RoKV0sXG4gICAgbGF5ZXJEYXRhOiBbLi4ubGF5ZXJEYXRhLnNsaWNlKDAsIGlkeCksIC4uLmxheWVyRGF0YS5zbGljZShpZHggKyAxLCBsYXllckRhdGEubGVuZ3RoKV0sXG4gICAgbGF5ZXJPcmRlcjogc3RhdGUubGF5ZXJPcmRlci5maWx0ZXIoaSA9PiBpICE9PSBpZHgpLm1hcChwaWQgPT4gKHBpZCA+IGlkeCA/IHBpZCAtIDEgOiBwaWQpKSxcbiAgICBjbGlja2VkOiBsYXllclRvUmVtb3ZlLmlzTGF5ZXJIb3ZlcmVkKGNsaWNrZWQpID8gdW5kZWZpbmVkIDogY2xpY2tlZCxcbiAgICBob3ZlckluZm86IGxheWVyVG9SZW1vdmUuaXNMYXllckhvdmVyZWQoaG92ZXJJbmZvKSA/IHVuZGVmaW5lZCA6IGhvdmVySW5mbyxcbiAgICBzcGxpdE1hcHM6IG5ld01hcHNcbiAgICAvLyBUT0RPOiB1cGRhdGUgZmlsdGVycywgY3JlYXRlIGhlbHBlciB0byByZW1vdmUgbGF5ZXIgZm9ybSBmaWx0ZXIgKHJlbW92ZSBsYXllcmlkIGFuZCBkYXRhaWQpIGlmIG1hcHBlZFxuICB9O1xuXG4gIHJldHVybiB1cGRhdGVBbmltYXRpb25Eb21haW4obmV3U3RhdGUpO1xufTtcblxuLyoqXG4gKiBSZW9yZGVyIGxheWVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGFjdGlvbi5vcmRlciBhbiBhcnJheSBvZiBsYXllciBpbmRleGVzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlb3JkZXJMYXllclVwZGF0ZXIgPSAoc3RhdGUsIHtvcmRlcn0pID0+ICh7XG4gIC4uLnN0YXRlLFxuICBsYXllck9yZGVyOiBvcmRlclxufSk7XG5cbi8qKlxuICogUmVtb3ZlIGEgZGF0YXNldCBhbmQgYWxsIGxheWVycywgZmlsdGVycywgdG9vbHRpcCBjb25maWdzIHRoYXQgYmFzZWQgb24gaXRcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24ua2V5IGRhdGFzZXQgaWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRGF0YXNldFVwZGF0ZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAvLyBleHRyYWN0IGRhdGFzZXQga2V5XG4gIGNvbnN0IHtrZXk6IGRhdGFzZXRLZXl9ID0gYWN0aW9uO1xuICBjb25zdCB7ZGF0YXNldHN9ID0gc3RhdGU7XG5cbiAgLy8gY2hlY2sgaWYgZGF0YXNldCBpcyBwcmVzZW50XG4gIGlmICghZGF0YXNldHNbZGF0YXNldEtleV0pIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICBjb25zdCB7XG4gICAgbGF5ZXJzLFxuICAgIGRhdGFzZXRzOiB7W2RhdGFzZXRLZXldOiBkYXRhc2V0LCAuLi5uZXdEYXRhc2V0c31cbiAgfSA9IHN0YXRlO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgY29uc3QgaW5kZXhlcyA9IGxheWVycy5yZWR1Y2UoKGxpc3RPZkluZGV4ZXMsIGxheWVyLCBpbmRleCkgPT4ge1xuICAgIGlmIChsYXllci5jb25maWcuZGF0YUlkID09PSBkYXRhc2V0S2V5KSB7XG4gICAgICBsaXN0T2ZJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdE9mSW5kZXhlcztcbiAgfSwgW10pO1xuXG4gIC8vIHJlbW92ZSBsYXllcnMgYW5kIGRhdGFzZXRzXG4gIGNvbnN0IHtuZXdTdGF0ZX0gPSBpbmRleGVzLnJlZHVjZShcbiAgICAoe25ld1N0YXRlOiBjdXJyZW50U3RhdGUsIGluZGV4Q291bnRlcn0sIGlkeCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gaWR4IC0gaW5kZXhDb3VudGVyO1xuICAgICAgY3VycmVudFN0YXRlID0gcmVtb3ZlTGF5ZXJVcGRhdGVyKGN1cnJlbnRTdGF0ZSwge2lkeDogY3VycmVudEluZGV4fSk7XG4gICAgICBpbmRleENvdW50ZXIrKztcbiAgICAgIHJldHVybiB7bmV3U3RhdGU6IGN1cnJlbnRTdGF0ZSwgaW5kZXhDb3VudGVyfTtcbiAgICB9LFxuICAgIHtuZXdTdGF0ZTogey4uLnN0YXRlLCBkYXRhc2V0czogbmV3RGF0YXNldHN9LCBpbmRleENvdW50ZXI6IDB9XG4gICk7XG5cbiAgLy8gcmVtb3ZlIGZpbHRlcnNcbiAgY29uc3QgZmlsdGVycyA9IHN0YXRlLmZpbHRlcnMuZmlsdGVyKGZpbHRlciA9PiAhZmlsdGVyLmRhdGFJZC5pbmNsdWRlcyhkYXRhc2V0S2V5KSk7XG5cbiAgLy8gdXBkYXRlIGludGVyYWN0aW9uQ29uZmlnXG4gIGxldCB7aW50ZXJhY3Rpb25Db25maWd9ID0gc3RhdGU7XG4gIGNvbnN0IHt0b29sdGlwfSA9IGludGVyYWN0aW9uQ29uZmlnO1xuICBpZiAodG9vbHRpcCkge1xuICAgIGNvbnN0IHtjb25maWd9ID0gdG9vbHRpcDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgIGNvbnN0IHtbZGF0YXNldEtleV06IGZpZWxkcywgLi4uZmllbGRzVG9TaG93fSA9IGNvbmZpZy5maWVsZHNUb1Nob3c7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgIGludGVyYWN0aW9uQ29uZmlnID0ge1xuICAgICAgLi4uaW50ZXJhY3Rpb25Db25maWcsXG4gICAgICB0b29sdGlwOiB7Li4udG9vbHRpcCwgY29uZmlnOiB7Li4uY29uZmlnLCBmaWVsZHNUb1Nob3d9fVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gey4uLm5ld1N0YXRlLCBmaWx0ZXJzLCBpbnRlcmFjdGlvbkNvbmZpZ307XG59O1xuXG4vKipcbiAqIHVwZGF0ZSBsYXllciBibGVuZGluZyBtb2RlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uLm1vZGUgb25lIG9mIGBhZGRpdGl2ZWAsIGBub3JtYWxgIGFuZCBgc3VidHJhY3RpdmVgXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUxheWVyQmxlbmRpbmdVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+ICh7XG4gIC4uLnN0YXRlLFxuICBsYXllckJsZW5kaW5nOiBhY3Rpb24ubW9kZVxufSk7XG5cbi8qKlxuICogRGlzcGxheSBkYXRhc2V0IHRhYmxlIGluIGEgbW9kYWxcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24uZGF0YUlkIGRhdGFzZXQgaWQgdG8gc2hvdyBpbiB0YWJsZVxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBzaG93RGF0YXNldFRhYmxlVXBkYXRlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZWRpdGluZ0RhdGFzZXQ6IGFjdGlvbi5kYXRhSWRcbiAgfTtcbn07XG5cbi8qKlxuICogcmVzZXQgdmlzU3RhdGUgdG8gaW5pdGlhbCBTdGF0ZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc2V0TWFwQ29uZmlnVXBkYXRlciA9IHN0YXRlID0+ICh7XG4gIC4uLklOSVRJQUxfVklTX1NUQVRFLFxuICAuLi5zdGF0ZS5pbml0aWFsU3RhdGUsXG4gIGluaXRpYWxTdGF0ZTogc3RhdGUuaW5pdGlhbFN0YXRlXG59KTtcblxuLyoqXG4gKiBQcm9wYWdhdGUgYHZpc1N0YXRlYCByZWR1Y2VyIHdpdGggYSBuZXcgY29uZmlndXJhdGlvbi4gQ3VycmVudCBjb25maWcgd2lsbCBiZSBvdmVycmlkZS5cbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24ucGF5bG9hZCBtYXAgY29uZmlnIHRvIGJlIHByb3BhZ2F0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24ucGF5bG9hZC5jb25maWcgbWFwIGNvbmZpZyB0byBiZSBwcm9wYWdhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLnBheWxvYWQub3B0aW9uIHtrZWVwRXhpc3RpbmdDb25maWc6IHRydWUgfCBmYWxzZX1cbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIgPSAoc3RhdGUsIHtwYXlsb2FkOiB7Y29uZmlnID0ge30sIG9wdGlvbnMgPSB7fX19KSA9PiB7XG4gIGlmICghY29uZmlnLnZpc1N0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGZpbHRlcnMsXG4gICAgbGF5ZXJzLFxuICAgIGludGVyYWN0aW9uQ29uZmlnLFxuICAgIGxheWVyQmxlbmRpbmcsXG4gICAgc3BsaXRNYXBzLFxuICAgIGFuaW1hdGlvbkNvbmZpZ1xuICB9ID0gY29uZmlnLnZpc1N0YXRlO1xuXG4gIGNvbnN0IHtrZWVwRXhpc3RpbmdDb25maWd9ID0gb3B0aW9ucztcblxuICAvLyByZXNldCBjb25maWcgaWYga2VlcEV4aXN0aW5nQ29uZmlnIGlzIGZhbHN5XG4gIGxldCBtZXJnZWRTdGF0ZSA9ICFrZWVwRXhpc3RpbmdDb25maWcgPyByZXNldE1hcENvbmZpZ1VwZGF0ZXIoc3RhdGUpIDogc3RhdGU7XG4gIG1lcmdlZFN0YXRlID0gbWVyZ2VMYXllcnMobWVyZ2VkU3RhdGUsIGxheWVycyk7XG4gIG1lcmdlZFN0YXRlID0gbWVyZ2VGaWx0ZXJzKG1lcmdlZFN0YXRlLCBmaWx0ZXJzKTtcbiAgbWVyZ2VkU3RhdGUgPSBtZXJnZUludGVyYWN0aW9ucyhtZXJnZWRTdGF0ZSwgaW50ZXJhY3Rpb25Db25maWcpO1xuICBtZXJnZWRTdGF0ZSA9IG1lcmdlTGF5ZXJCbGVuZGluZyhtZXJnZWRTdGF0ZSwgbGF5ZXJCbGVuZGluZyk7XG4gIG1lcmdlZFN0YXRlID0gbWVyZ2VTcGxpdE1hcHMobWVyZ2VkU3RhdGUsIHNwbGl0TWFwcyk7XG4gIG1lcmdlZFN0YXRlID0gbWVyZ2VBbmltYXRpb25Db25maWcobWVyZ2VkU3RhdGUsIGFuaW1hdGlvbkNvbmZpZyk7XG5cbiAgcmV0dXJuIG1lcmdlZFN0YXRlO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGxheWVyIGhvdmVyIGV2ZW50IHdpdGggaG92ZXJlZCBvYmplY3RcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24uaW5mbyBPYmplY3QgaG92ZXJlZCwgcmV0dXJuZWQgYnkgZGVjay5nbFxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBsYXllckhvdmVyVXBkYXRlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgaG92ZXJJbmZvOiBhY3Rpb24uaW5mb1xufSk7XG5cbi8qKlxuICogVHJpZ2dlciBsYXllciBjbGljayBldmVudCB3aXRoIGNsaWNrZWQgb2JqZWN0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLmluZm8gT2JqZWN0IGNsaWNrZWQsIHJldHVybmVkIGJ5IGRlY2suZ2xcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbGF5ZXJDbGlja1VwZGF0ZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIG1vdXNlUG9zOiBzdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZy5jb29yZGluYXRlLmVuYWJsZWRcbiAgICA/IHtcbiAgICAgICAgLi4uc3RhdGUubW91c2VQb3MsXG4gICAgICAgIHBpbm5lZDogc3RhdGUubW91c2VQb3MucGlubmVkID8gbnVsbCA6IGNsb25lRGVlcChzdGF0ZS5tb3VzZVBvcylcbiAgICAgIH1cbiAgICA6IHN0YXRlLm1vdXNlUG9zLFxuICBjbGlja2VkOiBhY3Rpb24uaW5mbyAmJiBhY3Rpb24uaW5mby5waWNrZWQgPyBhY3Rpb24uaW5mbyA6IG51bGxcbn0pO1xuXG4vKipcbiAqIFRyaWdnZXIgbWFwIGNsaWNrIGV2ZW50LCB1bnNlbGVjdCBjbGlja2VkIG9iamVjdFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcENsaWNrVXBkYXRlciA9IHN0YXRlID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBjbGlja2VkOiBudWxsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgbW91c2VNb3ZlVXBkYXRlciA9IChzdGF0ZSwge2V2dH0pID0+IHtcbiAgaWYgKE9iamVjdC52YWx1ZXMoc3RhdGUuaW50ZXJhY3Rpb25Db25maWcpLnNvbWUoY29uZmlnID0+IGNvbmZpZy5lbmFibGVkKSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIG1vdXNlUG9zOiB7XG4gICAgICAgIC4uLnN0YXRlLm1vdXNlUG9zLFxuICAgICAgICBtb3VzZVBvc2l0aW9uOiBbLi4uZXZ0LnBvaW50XSxcbiAgICAgICAgY29vcmRpbmF0ZTogWy4uLmV2dC5sbmdMYXRdXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn07XG4vKipcbiAqIFRvZ2dsZSB2aXNpYmlsaXR5IG9mIGEgbGF5ZXIgZm9yIGEgc3BsaXQgbWFwXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcnx1bmRlZmluZWR9IGFjdGlvbi5wYXlsb2FkIGluZGV4IG9mIHRoZSBzcGxpdCBtYXBcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlU3BsaXRNYXBVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+XG4gIHN0YXRlLnNwbGl0TWFwcyAmJiBzdGF0ZS5zcGxpdE1hcHMubGVuZ3RoID09PSAwXG4gICAgPyB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAvLyBtYXliZSB3ZSBzaG91bGQgdXNlIGFuIGFycmF5IHRvIHN0b3JlIHN0YXRlIGZvciBhIHNpbmdsZSBtYXAgYXMgd2VsbFxuICAgICAgICAvLyBpZiBjdXJyZW50IG1hcHMgbGVuZ3RoIGlzIGVxdWFsIHRvIDAgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgYWJvdXQgdG8gc3BsaXQgdGhlIHZpZXdcbiAgICAgICAgc3BsaXRNYXBzOiBjb21wdXRlU3BsaXRNYXBMYXllcnMoc3RhdGUubGF5ZXJzKVxuICAgICAgfVxuICAgIDogY2xvc2VTcGVjaWZpY01hcEF0SW5kZXgoc3RhdGUsIGFjdGlvbik7XG5cbi8qKlxuICogVG9nZ2xlIHZpc2liaWxpdHkgb2YgYSBsYXllciBpbiBhIHNwbGl0IG1hcFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGFjdGlvbi5tYXBJbmRleCBpbmRleCBvZiB0aGUgc3BsaXQgbWFwXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uLmxheWVySWQgaWQgb2YgdGhlIGxheWVyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUxheWVyRm9yTWFwVXBkYXRlciA9IChzdGF0ZSwge21hcEluZGV4LCBsYXllcklkfSkgPT4ge1xuICBjb25zdCB7c3BsaXRNYXBzfSA9IHN0YXRlO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgc3BsaXRNYXBzOiBzcGxpdE1hcHMubWFwKChzbSwgaSkgPT5cbiAgICAgIGkgPT09IG1hcEluZGV4XG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4uc3BsaXRNYXBzW2ldLFxuICAgICAgICAgICAgbGF5ZXJzOiB7XG4gICAgICAgICAgICAgIC4uLnNwbGl0TWFwc1tpXS5sYXllcnMsXG4gICAgICAgICAgICAgIC8vIGlmIGxheWVySWQgbm90IGluIGxheWVycywgc2V0IGl0IHRvIHZpc2libGVcbiAgICAgICAgICAgICAgW2xheWVySWRdOiAhc3BsaXRNYXBzW2ldLmxheWVyc1tsYXllcklkXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgOiBzbVxuICAgIClcbiAgfTtcbn07XG5cbi8qKlxuICogQWRkIG5ldyBkYXRhc2V0IHRvIGB2aXNTdGF0ZWAsIHdpdGggb3B0aW9uIHRvIGxvYWQgYSBtYXAgY29uZmlnIGFsb25nIHdpdGggdGhlIGRhdGFzZXRzXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD58T2JqZWN0fSBhY3Rpb24uZGF0YXNldHMgLSAqKipyZXF1aXJlZCoqIGRhdGFzZXRzIGNhbiBiZSBhIGRhdGFzZXQgb3IgYW4gYXJyYXkgb2YgZGF0YXNldHNcbiAqIEVhY2ggZGF0YXNldCBvYmplY3QgbmVlZHMgdG8gaGF2ZSBgaW5mb2AgYW5kIGBkYXRhYCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24uZGF0YXNldHMuaW5mbyAtaW5mbyBvZiBhIGRhdGFzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24uZGF0YXNldHMuaW5mby5pZCAtIGlkIG9mIHRoaXMgZGF0YXNldC4gSWYgY29uZmlnIGlzIGRlZmluZWQsIGBpZGAgc2hvdWxkIG1hdGNoZXMgdGhlIGBkYXRhSWRgIGluIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24uZGF0YXNldHMuaW5mby5sYWJlbCAtIEEgZGlzcGxheSBuYW1lIG9mIHRoaXMgZGF0YXNldFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5kYXRhc2V0cy5kYXRhIC0gKioqcmVxdWlyZWQqKiBUaGUgZGF0YSBvYmplY3QsIGluIGEgdGFidWxhciBmb3JtYXQgd2l0aCAyIHByb3BlcnRpZXMgYGZpZWxkc2AgYW5kIGByb3dzYFxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBhY3Rpb24uZGF0YXNldHMuZGF0YS5maWVsZHMgLSAqKipyZXF1aXJlZCoqIEFycmF5IG9mIGZpZWxkcyxcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24uZGF0YXNldHMuZGF0YS5maWVsZHMubmFtZSAtICoqKnJlcXVpcmVkKiogTmFtZSBvZiB0aGUgZmllbGQsXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gYWN0aW9uLmRhdGFzZXRzLmRhdGEucm93cyAtICoqKnJlcXVpcmVkKiogQXJyYXkgb2Ygcm93cywgaW4gYSB0YWJ1bGFyIGZvcm1hdCB3aXRoIGBmaWVsZHNgIGFuZCBgcm93c2BcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24ub3B0aW9ucyBvcHRpb24gb2JqZWN0IGB7Y2VudGVyTWFwOiB0cnVlLCBrZWVwRXhpc3RpbmdDb25maWc6IGZhbHNlfWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24uY29uZmlnIG1hcCBjb25maWdcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVZpc0RhdGFVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgLy8gZGF0YXNldHMgY2FuIGJlIGEgc2luZ2xlIGRhdGEgZW50cmllcyBvciBhbiBhcnJheSBvZiBtdWx0aXBsZSBkYXRhIGVudHJpZXNcbiAgY29uc3Qge2NvbmZpZywgb3B0aW9uc30gPSBhY3Rpb247XG5cbiAgY29uc3QgZGF0YXNldHMgPSB0b0FycmF5KGFjdGlvbi5kYXRhc2V0cyk7XG5cbiAgY29uc3QgbmV3RGF0YUVudHJpZXMgPSBkYXRhc2V0cy5yZWR1Y2UoXG4gICAgKGFjY3UsIHtpbmZvID0ge30sIGRhdGF9KSA9PiAoe1xuICAgICAgLi4uYWNjdSxcbiAgICAgIC4uLihjcmVhdGVOZXdEYXRhRW50cnkoe2luZm8sIGRhdGF9LCBzdGF0ZS5kYXRhc2V0cykgfHwge30pXG4gICAgfSksXG4gICAge31cbiAgKTtcblxuICBpZiAoIU9iamVjdC5rZXlzKG5ld0RhdGFFbnRyaWVzKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICAvLyBhcHBseSBjb25maWcgaWYgcGFzc2VkIGZyb20gYWN0aW9uXG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBjb25maWdcbiAgICA/IHJlY2VpdmVNYXBDb25maWdVcGRhdGVyKHN0YXRlLCB7XG4gICAgICAgIHBheWxvYWQ6IHtjb25maWcsIG9wdGlvbnN9XG4gICAgICB9KVxuICAgIDogc3RhdGU7XG5cbiAgY29uc3Qgc3RhdGVXaXRoTmV3RGF0YSA9IHtcbiAgICAuLi5wcmV2aW91c1N0YXRlLFxuICAgIGRhdGFzZXRzOiB7XG4gICAgICAuLi5wcmV2aW91c1N0YXRlLmRhdGFzZXRzLFxuICAgICAgLi4ubmV3RGF0YUVudHJpZXNcbiAgICB9XG4gIH07XG5cbiAgLy8gcHJldmlvdXNseSBzYXZlZCBjb25maWcgYmVmb3JlIGRhdGEgbG9hZGVkXG4gIGNvbnN0IHtcbiAgICBmaWx0ZXJUb0JlTWVyZ2VkID0gW10sXG4gICAgbGF5ZXJUb0JlTWVyZ2VkID0gW10sXG4gICAgaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkID0ge30sXG4gICAgc3BsaXRNYXBzVG9CZU1lcmdlZCA9IFtdXG4gIH0gPSBzdGF0ZVdpdGhOZXdEYXRhO1xuXG4gIC8vIFdlIG5lZWQgdG8gbWVyZ2UgbGF5ZXJzIGJlZm9yZSBmaWx0ZXJzIGJlY2F1c2UgcG9seWdvbiBmaWx0ZXJzIHJlcXVpcmVzIGxheWVycyB0byBiZSBsb2FkZWRcbiAgbGV0IG1lcmdlZFN0YXRlID0gbWVyZ2VMYXllcnMoc3RhdGVXaXRoTmV3RGF0YSwgbGF5ZXJUb0JlTWVyZ2VkKTtcblxuICBtZXJnZWRTdGF0ZSA9IG1lcmdlRmlsdGVycyhtZXJnZWRTdGF0ZSwgZmlsdGVyVG9CZU1lcmdlZCk7XG5cbiAgLy8gbWVyZ2Ugc3RhdGUgd2l0aCBzYXZlZCBzcGxpdE1hcHNcbiAgbWVyZ2VkU3RhdGUgPSBtZXJnZVNwbGl0TWFwcyhtZXJnZWRTdGF0ZSwgc3BsaXRNYXBzVG9CZU1lcmdlZCk7XG5cbiAgbGV0IG5ld0xheWVycyA9IG1lcmdlZFN0YXRlLmxheWVycy5maWx0ZXIobCA9PiBsLmNvbmZpZy5kYXRhSWQgaW4gbmV3RGF0YUVudHJpZXMpO1xuXG4gIGlmICghbmV3TGF5ZXJzLmxlbmd0aCkge1xuICAgIC8vIG5vIGxheWVyIG1lcmdlZCwgZmluZCBkZWZhdWx0c1xuICAgIGNvbnN0IHJlc3VsdCA9IGFkZERlZmF1bHRMYXllcnMobWVyZ2VkU3RhdGUsIG5ld0RhdGFFbnRyaWVzKTtcbiAgICBtZXJnZWRTdGF0ZSA9IHJlc3VsdC5zdGF0ZTtcbiAgICBuZXdMYXllcnMgPSByZXN1bHQubmV3TGF5ZXJzO1xuICB9XG5cbiAgaWYgKG1lcmdlZFN0YXRlLnNwbGl0TWFwcy5sZW5ndGgpIHtcbiAgICAvLyBpZiBtYXAgaXMgc3BsaXQsIGFkZCBuZXcgbGF5ZXJzIHRvIHNwbGl0TWFwc1xuICAgIG5ld0xheWVycyA9IG1lcmdlZFN0YXRlLmxheWVycy5maWx0ZXIobCA9PiBsLmNvbmZpZy5kYXRhSWQgaW4gbmV3RGF0YUVudHJpZXMpO1xuICAgIG1lcmdlZFN0YXRlID0ge1xuICAgICAgLi4ubWVyZ2VkU3RhdGUsXG4gICAgICBzcGxpdE1hcHM6IGFkZE5ld0xheWVyc1RvU3BsaXRNYXAobWVyZ2VkU3RhdGUuc3BsaXRNYXBzLCBuZXdMYXllcnMpXG4gICAgfTtcbiAgfVxuXG4gIC8vIG1lcmdlIHN0YXRlIHdpdGggc2F2ZWQgaW50ZXJhY3Rpb25zXG4gIG1lcmdlZFN0YXRlID0gbWVyZ2VJbnRlcmFjdGlvbnMobWVyZ2VkU3RhdGUsIGludGVyYWN0aW9uVG9CZU1lcmdlZCk7XG5cbiAgLy8gaWYgbm8gdG9vbHRpcHMgbWVyZ2VkIGFkZCBkZWZhdWx0IHRvb2x0aXBzXG4gIE9iamVjdC5rZXlzKG5ld0RhdGFFbnRyaWVzKS5mb3JFYWNoKGRhdGFJZCA9PiB7XG4gICAgY29uc3QgdG9vbHRpcEZpZWxkcyA9IG1lcmdlZFN0YXRlLmludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXAuY29uZmlnLmZpZWxkc1RvU2hvd1tkYXRhSWRdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0b29sdGlwRmllbGRzKSB8fCAhdG9vbHRpcEZpZWxkcy5sZW5ndGgpIHtcbiAgICAgIG1lcmdlZFN0YXRlID0gYWRkRGVmYXVsdFRvb2x0aXBzKG1lcmdlZFN0YXRlLCBuZXdEYXRhRW50cmllc1tkYXRhSWRdKTtcbiAgICB9XG4gIH0pO1xuXG4gIGxldCB1cGRhdGVkU3RhdGUgPSB1cGRhdGVBbGxMYXllckRvbWFpbkRhdGEobWVyZ2VkU3RhdGUsIE9iamVjdC5rZXlzKG5ld0RhdGFFbnRyaWVzKSk7XG5cbiAgLy8gcmVnaXN0ZXIgbGF5ZXIgYW5pbWF0aW9uIGRvbWFpbixcbiAgLy8gbmVlZCB0byBiZSBjYWxsZWQgYWZ0ZXIgbGF5ZXIgZGF0YSBpcyBjYWxjdWxhdGVkXG4gIHVwZGF0ZWRTdGF0ZSA9IHVwZGF0ZUFuaW1hdGlvbkRvbWFpbih1cGRhdGVkU3RhdGUpO1xuXG4gIHJldHVybiB1cGRhdGVkU3RhdGU7XG59O1xuLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4vKipcbiAqIFdoZW4gYSB1c2VyIGNsaWNrcyBvbiB0aGUgc3BlY2lmaWMgbWFwIGNsb3NpbmcgaWNvblxuICogdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2xvc2UgdGhlIHNlbGVjdGVkIG1hcFxuICogYW5kIHdpbGwgbWVyZ2UgdGhlIHJlbWFpbmluZyBvbmUgd2l0aCB0aGUgZ2xvYmFsIHN0YXRlXG4gKiBUT0RPOiBpIHRoaW5rIGluIHRoZSBmdXR1cmUgdGhpcyBhY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBtZXJnZSBtYXAgbGF5ZXJzIHdpdGggZ2xvYmFsIHNldHRpbmdzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICovXG5mdW5jdGlvbiBjbG9zZVNwZWNpZmljTWFwQXRJbmRleChzdGF0ZSwgYWN0aW9uKSB7XG4gIC8vIHJldHJpZXZlIGxheWVycyBtZXRhIGRhdGEgZnJvbSB0aGUgcmVtYWluaW5nIG1hcCB0aGF0IHdlIG5lZWQgdG8ga2VlcFxuICBjb25zdCBpbmRleFRvUmV0cmlldmUgPSAxIC0gYWN0aW9uLnBheWxvYWQ7XG4gIGNvbnN0IG1hcExheWVycyA9IHN0YXRlLnNwbGl0TWFwc1tpbmRleFRvUmV0cmlldmVdLmxheWVycztcbiAgY29uc3Qge2xheWVyc30gPSBzdGF0ZTtcblxuICAvLyB1cGRhdGUgbGF5ZXIgdmlzaWJpbGl0eVxuICBjb25zdCBuZXdMYXllcnMgPSBsYXllcnMubWFwKGxheWVyID0+XG4gICAgIW1hcExheWVyc1tsYXllci5pZF0gJiYgbGF5ZXIuY29uZmlnLmlzVmlzaWJsZVxuICAgICAgPyBsYXllci51cGRhdGVMYXllckNvbmZpZyh7XG4gICAgICAgICAgLy8gaWYgbGF5ZXIuaWQgaXMgbm90IGluIG1hcExheWVycywgaXQgc2hvdWxkIGJlIGluVmlzaWJsZVxuICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2VcbiAgICAgICAgfSlcbiAgICAgIDogbGF5ZXJcbiAgKTtcblxuICAvLyBkZWxldGUgbWFwXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBuZXdMYXllcnMsXG4gICAgc3BsaXRNYXBzOiBbXVxuICB9O1xufVxuXG4vKipcbiAqIFRyaWdnZXIgZmlsZSBsb2FkaW5nIGRpc3BhdGNoIGBhZGREYXRhVG9NYXBgIGlmIHN1Y2NlZWQsIG9yIGBsb2FkRmlsZXNFcnJgIGlmIGZhaWxlZFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIGFjdGlvblxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBhY3Rpb24uZmlsZXMgYXJyYXkgb2YgZmlsZWJsb2JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbi5vbkZpbmlzaCBhY3Rpb24gY3JlYXRvciB0byBleGVjdXRlIGFmdGVyIGxvYWQgZmlsZSBzdWNjZWVkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRGaWxlc1VwZGF0ZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICBjb25zdCB7ZmlsZXMsIG9uRmluaXNoID0gbG9hZEZpbGVTdWNjZXNzfSA9IGFjdGlvbjtcbiAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCBmaWxlQ2FjaGUgPSBbXTtcbiAgcmV0dXJuIHdpdGhUYXNrKFxuICAgIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZmlsZUxvYWRpbmc6IHRydWUsXG4gICAgICBmaWxlTG9hZGluZ1Byb2dyZXNzOiAwXG4gICAgfSxcbiAgICBtYWtlTG9hZEZpbGVUYXNrKGZpbGVzLmxlbmd0aCwgZmlsZXMsIGZpbGVDYWNoZSwgb25GaW5pc2gpXG4gICk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbG9hZE5leHRGaWxlVXBkYXRlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIGNvbnN0IHtmaWxlQ2FjaGUsIGZpbGVzVG9Mb2FkLCB0b3RhbENvdW50LCBvbkZpbmlzaH0gPSBhY3Rpb247XG4gIGNvbnN0IGZpbGVMb2FkaW5nUHJvZ3Jlc3MgPSAoKHRvdGFsQ291bnQgLSBmaWxlc1RvTG9hZC5sZW5ndGgpIC8gdG90YWxDb3VudCkgKiAxMDA7XG5cbiAgcmV0dXJuIHdpdGhUYXNrKFxuICAgIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZmlsZUxvYWRpbmdQcm9ncmVzc1xuICAgIH0sXG4gICAgbWFrZUxvYWRGaWxlVGFzayh0b3RhbENvdW50LCBmaWxlc1RvTG9hZCwgZmlsZUNhY2hlLCBvbkZpbmlzaClcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VMb2FkRmlsZVRhc2sodG90YWxDb3VudCwgZmlsZXNUb0xvYWQsIGZpbGVDYWNoZSwgb25GaW5pc2gpIHtcbiAgY29uc3QgW2ZpbGUsIC4uLnJlbWFpbmluZ0ZpbGVzVG9Mb2FkXSA9IGZpbGVzVG9Mb2FkO1xuXG4gIHJldHVybiBMT0FEX0ZJTEVfVEFTSyh7ZmlsZSwgZmlsZUNhY2hlfSkuYmltYXAoXG4gICAgLy8gc3VjY2Vzc1xuICAgIHJlc3VsdCA9PlxuICAgICAgcmVtYWluaW5nRmlsZXNUb0xvYWQubGVuZ3RoXG4gICAgICAgID8gbG9hZE5leHRGaWxlKHtcbiAgICAgICAgICAgIGZpbGVDYWNoZTogcmVzdWx0LFxuICAgICAgICAgICAgZmlsZXNUb0xvYWQ6IHJlbWFpbmluZ0ZpbGVzVG9Mb2FkLFxuICAgICAgICAgICAgdG90YWxDb3VudCxcbiAgICAgICAgICAgIG9uRmluaXNoXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBvbkZpbmlzaChyZXN1bHQpLFxuICAgIC8vIGVycm9yXG4gICAgbG9hZEZpbGVzRXJyXG4gICk7XG59XG5cbi8qKlxuICogVHJpZ2dlciBsb2FkaW5nIGZpbGUgZXJyb3JcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7Kn0gYWN0aW9uLmVycm9yXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRGaWxlc0VyclVwZGF0ZXIgPSAoc3RhdGUsIHtlcnJvcn0pID0+ICh7XG4gIC4uLnN0YXRlLFxuICBmaWxlTG9hZGluZzogZmFsc2UsXG4gIGZpbGVMb2FkaW5nRXJyOiBlcnJvclxufSk7XG5cbi8qKlxuICogV2hlbiBzZWxlY3QgZGF0YXNldCBmb3IgZXhwb3J0LCBhcHBseSBjcHUgZmlsdGVyIHRvIHNlbGVjdGVkIGRhdGFzZXRcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbi5kYXRhSWQgZGF0YXNldCBpZFxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBhcHBseUNQVUZpbHRlclVwZGF0ZXIgPSAoc3RhdGUsIHtkYXRhSWR9KSA9PiB7XG4gIC8vIGFwcGx5IGNwdUZpbHRlclxuICBjb25zdCBkYXRhSWRzID0gdG9BcnJheShkYXRhSWQpO1xuXG4gIHJldHVybiBkYXRhSWRzLnJlZHVjZSgoYWNjdSwgaWQpID0+IGZpbHRlckRhdGFzZXRDUFUoYWNjdSwgaWQpLCBzdGF0ZSk7XG59O1xuXG4vKipcbiAqIFVzZXIgaW5wdXQgdG8gdXBkYXRlIHRoZSBpbmZvIG9mIHRoZSBtYXBcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24uaW5mbyB7dGl0bGU6ICdoZWxsbyd9XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldE1hcEluZm9VcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+ICh7XG4gIC4uLnN0YXRlLFxuICBtYXBJbmZvOiB7XG4gICAgLi4uc3RhdGUubWFwSW5mbyxcbiAgICAuLi5hY3Rpb24uaW5mb1xuICB9XG59KTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHVwZGF0ZSBBbGwgbGF5ZXIgZG9tYWluIGFuZCBsYXllciBkYXRhIG9mIHN0YXRlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZGF0YXNldHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRGVmYXVsdExheWVycyhzdGF0ZSwgZGF0YXNldHMpIHtcbiAgY29uc3QgZGVmYXVsdExheWVycyA9IE9iamVjdC52YWx1ZXMoZGF0YXNldHMpLnJlZHVjZShcbiAgICAoYWNjdSwgZGF0YXNldCkgPT4gWy4uLmFjY3UsIC4uLihmaW5kRGVmYXVsdExheWVyKGRhdGFzZXQsIHN0YXRlLmxheWVyQ2xhc3NlcykgfHwgW10pXSxcbiAgICBbXVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgc3RhdGU6IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgbGF5ZXJzOiBbLi4uc3RhdGUubGF5ZXJzLCAuLi5kZWZhdWx0TGF5ZXJzXSxcbiAgICAgIGxheWVyT3JkZXI6IFtcbiAgICAgICAgLy8gcHV0IG5ldyBsYXllcnMgb24gdG9wIG9mIG9sZCBvbmVzXG4gICAgICAgIC4uLmRlZmF1bHRMYXllcnMubWFwKChfLCBpKSA9PiBzdGF0ZS5sYXllcnMubGVuZ3RoICsgaSksXG4gICAgICAgIC4uLnN0YXRlLmxheWVyT3JkZXJcbiAgICAgIF1cbiAgICB9LFxuICAgIG5ld0xheWVyczogZGVmYXVsdExheWVyc1xuICB9O1xufVxuXG4vKipcbiAqIGhlbHBlciBmdW5jdGlvbiB0byBmaW5kIGRlZmF1bHQgdG9vbHRpcHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFzZXRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRGVmYXVsdFRvb2x0aXBzKHN0YXRlLCBkYXRhc2V0KSB7XG4gIGNvbnN0IHRvb2x0aXBGaWVsZHMgPSBmaW5kRmllbGRzVG9TaG93KGRhdGFzZXQpO1xuICBjb25zdCBtZXJnZWQgPSB7XG4gICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Db25maWcudG9vbHRpcC5jb25maWcuZmllbGRzVG9TaG93LFxuICAgIC4uLnRvb2x0aXBGaWVsZHNcbiAgfTtcblxuICByZXR1cm4gc2V0KFsnaW50ZXJhY3Rpb25Db25maWcnLCAndG9vbHRpcCcsICdjb25maWcnLCAnZmllbGRzVG9TaG93J10sIG1lcmdlZCwgc3RhdGUpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byB1cGRhdGUgbGF5ZXIgZG9tYWlucyBmb3IgYW4gYXJyYXkgb2YgZGF0YXNldHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtBcnJheXxBcnJheTxzdHJpbmc+fSBkYXRhSWQgZGF0YXNldCBpZCBvciBhcnJheSBvZiBkYXRhc2V0IGlkc1xuICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZWRGaWx0ZXIgaWYgaXMgY2FsbGVkIGJ5IHNldEZpbHRlciwgdGhlIGZpbHRlciB0aGF0IGhhcyB1cGRhdGVkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUFsbExheWVyRG9tYWluRGF0YShzdGF0ZSwgZGF0YUlkLCB1cGRhdGVkRmlsdGVyKSB7XG4gIGNvbnN0IGRhdGFJZHMgPSB0eXBlb2YgZGF0YUlkID09PSAnc3RyaW5nJyA/IFtkYXRhSWRdIDogZGF0YUlkO1xuICBjb25zdCBuZXdMYXllcnMgPSBbXTtcbiAgY29uc3QgbmV3TGF5ZXJEYXRhID0gW107XG5cbiAgc3RhdGUubGF5ZXJzLmZvckVhY2goKG9sZExheWVyLCBpKSA9PiB7XG4gICAgaWYgKG9sZExheWVyLmNvbmZpZy5kYXRhSWQgJiYgZGF0YUlkcy5pbmNsdWRlcyhvbGRMYXllci5jb25maWcuZGF0YUlkKSkge1xuICAgICAgLy8gTm8gbmVlZCB0byByZWNhbGN1bGF0ZSBsYXllciBkb21haW4gaWYgZmlsdGVyIGhhcyBmaXhlZCBkb21haW5cbiAgICAgIGNvbnN0IG5ld0xheWVyID1cbiAgICAgICAgdXBkYXRlZEZpbHRlciAmJiB1cGRhdGVkRmlsdGVyLmZpeGVkRG9tYWluXG4gICAgICAgICAgPyBvbGRMYXllclxuICAgICAgICAgIDogb2xkTGF5ZXIudXBkYXRlTGF5ZXJEb21haW4oc3RhdGUuZGF0YXNldHMsIHVwZGF0ZWRGaWx0ZXIpO1xuXG4gICAgICBjb25zdCB7bGF5ZXJEYXRhLCBsYXllcn0gPSBjYWxjdWxhdGVMYXllckRhdGEobmV3TGF5ZXIsIHN0YXRlLCBzdGF0ZS5sYXllckRhdGFbaV0pO1xuXG4gICAgICBuZXdMYXllcnMucHVzaChsYXllcik7XG4gICAgICBuZXdMYXllckRhdGEucHVzaChsYXllckRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdMYXllcnMucHVzaChvbGRMYXllcik7XG4gICAgICBuZXdMYXllckRhdGEucHVzaChzdGF0ZS5sYXllckRhdGFbaV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBuZXdMYXllcnMsXG4gICAgbGF5ZXJEYXRhOiBuZXdMYXllckRhdGFcbiAgfTtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVBbmltYXRpb25Eb21haW4oc3RhdGUpIHtcbiAgLy8gbWVyZ2UgYWxsIGFuaW1hdGFibGUgbGF5ZXIgZG9tYWluIGFuZCB1cGRhdGUgZ2xvYmFsIGNvbmZpZ1xuICBjb25zdCBhbmltYXRhYmxlTGF5ZXJzID0gc3RhdGUubGF5ZXJzLmZpbHRlcihcbiAgICBsID0+XG4gICAgICBsLmNvbmZpZy5pc1Zpc2libGUgJiZcbiAgICAgIGwuY29uZmlnLmFuaW1hdGlvbiAmJlxuICAgICAgbC5jb25maWcuYW5pbWF0aW9uLmVuYWJsZWQgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkobC5hbmltYXRpb25Eb21haW4pXG4gICk7XG5cbiAgaWYgKCFhbmltYXRhYmxlTGF5ZXJzLmxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGFuaW1hdGlvbkNvbmZpZzogZGVmYXVsdEFuaW1hdGlvbkNvbmZpZ1xuICAgIH07XG4gIH1cblxuICBjb25zdCBtZXJnZWREb21haW4gPSBhbmltYXRhYmxlTGF5ZXJzLnJlZHVjZShcbiAgICAoYWNjdSwgbGF5ZXIpID0+IFtcbiAgICAgIE1hdGgubWluKGFjY3VbMF0sIGxheWVyLmFuaW1hdGlvbkRvbWFpblswXSksXG4gICAgICBNYXRoLm1heChhY2N1WzFdLCBsYXllci5hbmltYXRpb25Eb21haW5bMV0pXG4gICAgXSxcbiAgICBbTnVtYmVyKEluZmluaXR5KSwgLUluZmluaXR5XVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgYW5pbWF0aW9uQ29uZmlnOiB7XG4gICAgICAuLi5zdGF0ZS5hbmltYXRpb25Db25maWcsXG4gICAgICBjdXJyZW50VGltZTogaXNJblJhbmdlKHN0YXRlLmFuaW1hdGlvbkNvbmZpZy5jdXJyZW50VGltZSwgbWVyZ2VkRG9tYWluKVxuICAgICAgICA/IHN0YXRlLmFuaW1hdGlvbkNvbmZpZy5jdXJyZW50VGltZVxuICAgICAgICA6IG1lcmdlZERvbWFpblswXSxcbiAgICAgIGRvbWFpbjogbWVyZ2VkRG9tYWluXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgc3RhdHVzIG9mIHRoZSBlZGl0b3JcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgdG8gc2V0IHRvIGVkaXRvciB0b1xuICogQHJldHVybiB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHNldEVkaXRvck1vZGVVcGRhdGVyID0gKHN0YXRlLCB7bW9kZX0pID0+ICh7XG4gIC4uLnN0YXRlLFxuICBlZGl0b3I6IHtcbiAgICAuLi5zdGF0ZS5lZGl0b3IsXG4gICAgbW9kZSxcbiAgICBzZWxlY3RlZEZlYXR1cmU6IG51bGxcbiAgfVxufSk7XG5cbi8vIGNvbnN0IGZlYXR1cmVUb0ZpbHRlclZhbHVlID0gKGZlYXR1cmUpID0+ICh7Li4uZmVhdHVyZSwgaWQ6IGZlYXR1cmUuaWR9KTtcbi8qKlxuICogVXBkYXRlIGVkaXRvciBmZWF0dXJlc1xuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge1tPYmplY3RdfSBmZWF0dXJlcyB0byBzdG9yZVxuICogQHJldHVybiB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEZlYXR1cmVzVXBkYXRlcihzdGF0ZSwge2ZlYXR1cmVzID0gW119KSB7XG4gIGNvbnN0IGxhc3RGZWF0dXJlID0gZmVhdHVyZXMubGVuZ3RoICYmIGZlYXR1cmVzW2ZlYXR1cmVzLmxlbmd0aCAtIDFdO1xuXG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVkaXRvcjoge1xuICAgICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgICAgLy8gb25seSBzYXZlIG5vbmUgZmlsdGVyIGZlYXR1cmVzIHRvIGVkaXRvclxuICAgICAgZmVhdHVyZXM6IGZlYXR1cmVzLmZpbHRlcihmID0+ICFnZXRGaWx0ZXJJZEluRmVhdHVyZShmKSksXG4gICAgICBtb2RlOiBsYXN0RmVhdHVyZSAmJiBsYXN0RmVhdHVyZS5wcm9wZXJ0aWVzLmlzQ2xvc2VkID8gRURJVE9SX01PREVTLkVESVQgOiBzdGF0ZS5lZGl0b3IubW9kZVxuICAgIH1cbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBleGlzdGluZyBmZWF0dXJlXG4gIGNvbnN0IHtzZWxlY3RlZEZlYXR1cmV9ID0gc3RhdGUuZWRpdG9yO1xuXG4gIC8vIElmIG5vIGZlYXR1cmUgaXMgc2VsZWN0ZWQgd2UgY2FuIHNpbXBseSByZXR1cm4gc2luY2Ugbm8gb3BlcmF0aW9uc1xuICBpZiAoIXNlbGVjdGVkRmVhdHVyZSkge1xuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfVxuXG4gIC8vIFRPRE86IGNoZWNrIGlmIHRoZSBmZWF0dXJlIGhhcyBjaGFuZ2VkXG4gIGNvbnN0IGZlYXR1cmUgPSBmZWF0dXJlcy5maW5kKGYgPT4gZi5pZCA9PT0gc2VsZWN0ZWRGZWF0dXJlLmlkKTtcblxuICAvLyBpZiBmZWF0dXJlIGlzIHBhcnQgb2YgYSBmaWx0ZXJcbiAgY29uc3QgZmlsdGVySWQgPSBmZWF0dXJlICYmIGdldEZpbHRlcklkSW5GZWF0dXJlKGZlYXR1cmUpO1xuICBpZiAoZmlsdGVySWQpIHtcbiAgICBjb25zdCBmZWF0dXJlVmFsdWUgPSBmZWF0dXJlVG9GaWx0ZXJWYWx1ZShmZWF0dXJlLCBmaWx0ZXJJZCk7XG4gICAgY29uc3QgZmlsdGVySWR4ID0gc3RhdGUuZmlsdGVycy5maW5kSW5kZXgoZmlsID0+IGZpbC5pZCA9PT0gZmlsdGVySWQpO1xuICAgIHJldHVybiBzZXRGaWx0ZXJVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgICBpZHg6IGZpbHRlcklkeCxcbiAgICAgIHByb3A6ICd2YWx1ZScsXG4gICAgICB2YWx1ZTogZmVhdHVyZVZhbHVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IHNlbGVjdGVkIGZlYXR1cmVcbiAqIEBtZW1iZXJvZiB1aVN0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdWlTdGF0ZWBcbiAqIEBwYXJhbSB7W09iamVjdF19IGZlYXR1cmVzIHRvIHN0b3JlXG4gKiBAcmV0dXJuIHtPYmplY3R9IG5leHRTdGF0ZVxuICovXG5leHBvcnQgY29uc3Qgc2V0U2VsZWN0ZWRGZWF0dXJlVXBkYXRlciA9IChzdGF0ZSwge2ZlYXR1cmV9KSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgZWRpdG9yOiB7XG4gICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgIHNlbGVjdGVkRmVhdHVyZTogZmVhdHVyZVxuICB9XG59KTtcblxuLyoqXG4gKiBEZWxldGUgZXhpc3RpbmcgZmVhdHVyZSBmcm9tIGZpbHRlcnNcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdGVkRmVhdHVyZUlkIGZlYXR1cmUgdG8gZGVsZXRlXG4gKiBAcmV0dXJuIHtPYmplY3R9IG5leHRTdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlRmVhdHVyZVVwZGF0ZXIoc3RhdGUsIHtmZWF0dXJlfSkge1xuICBpZiAoIWZlYXR1cmUpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlZGl0b3I6IHtcbiAgICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICAgIHNlbGVjdGVkRmVhdHVyZTogbnVsbFxuICAgIH1cbiAgfTtcblxuICBpZiAoZ2V0RmlsdGVySWRJbkZlYXR1cmUoZmVhdHVyZSkpIHtcbiAgICBjb25zdCBmaWx0ZXJJZHggPSBuZXdTdGF0ZS5maWx0ZXJzLmZpbmRJbmRleChmID0+IGYuaWQgPT09IGdldEZpbHRlcklkSW5GZWF0dXJlKGZlYXR1cmUpKTtcblxuICAgIHJldHVybiBmaWx0ZXJJZHggPiAtMSA/IHJlbW92ZUZpbHRlclVwZGF0ZXIobmV3U3RhdGUsIHtpZHg6IGZpbHRlcklkeH0pIDogbmV3U3RhdGU7XG4gIH1cblxuICAvLyBtb2RpZnkgZWRpdG9yIG9iamVjdFxuICBjb25zdCBuZXdFZGl0b3IgPSB7XG4gICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgIGZlYXR1cmVzOiBzdGF0ZS5lZGl0b3IuZmVhdHVyZXMuZmlsdGVyKGYgPT4gZi5pZCAhPT0gZmVhdHVyZS5pZCksXG4gICAgc2VsZWN0ZWRGZWF0dXJlOiBudWxsXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlZGl0b3I6IG5ld0VkaXRvclxuICB9O1xufVxuXG4vKipcbiAqIFRvZ2dsZSBmZWF0dXJlIGFzIGxheWVyIGZpbHRlclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXlsb2FkLmZlYXR1cmVJZFxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQubGF5ZXJcbiAqIEByZXR1cm4ge09iamVjdH0gbmV4dFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQb2x5Z29uRmlsdGVyTGF5ZXJVcGRhdGVyKHN0YXRlLCBwYXlsb2FkKSB7XG4gIGNvbnN0IHtsYXllciwgZmVhdHVyZX0gPSBwYXlsb2FkO1xuICBjb25zdCBmaWx0ZXJJZCA9IGdldEZpbHRlcklkSW5GZWF0dXJlKGZlYXR1cmUpO1xuXG4gIC8vIGxldCBuZXdGaWx0ZXIgPSBudWxsO1xuICBsZXQgZmlsdGVySWR4O1xuICBsZXQgbmV3TGF5ZXJJZCA9IFtsYXllci5pZF07XG4gIGxldCBuZXdTdGF0ZSA9IHN0YXRlO1xuICAvLyBJZiBwb2x5Z29uIGZpbHRlciBhbHJlYWR5IGV4aXN0cywgd2UgbmVlZCB0byBmaW5kIG91dCBpZiB0aGUgY3VycmVudCBsYXllciBpcyBhbHJlYWR5IGluY2x1ZGVkXG4gIGlmIChmaWx0ZXJJZCkge1xuICAgIGZpbHRlcklkeCA9IHN0YXRlLmZpbHRlcnMuZmluZEluZGV4KGYgPT4gZi5pZCA9PT0gZmlsdGVySWQpO1xuXG4gICAgaWYgKCFzdGF0ZS5maWx0ZXJzW2ZpbHRlcklkeF0pIHtcbiAgICAgIC8vIHdoYXQgaWYgZmlsdGVyIGRvZXNuJ3QgZXhpc3Q/Li4uIG5vdCBwb3NzaWJsZS5cbiAgICAgIC8vIGJlY2F1c2UgZmVhdHVyZXMgaW4gdGhlIGVkaXRvciBpcyBwYXNzZWQgaW4gZnJvbSBmaWx0ZXJzIGFuZCBlZGl0b3JzLlxuICAgICAgLy8gYnV0IHdlIHdpbGwgbW92ZSB0aGlzIGZlYXR1cmUgYmFjayB0byBlZGl0b3IganVzdCBpbiBjYXNlXG4gICAgICBjb25zdCBub25lRmlsdGVyRmVhdHVyZSA9IHtcbiAgICAgICAgLi4uZmVhdHVyZSxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIC4uLmZlYXR1cmUucHJvcGVydGllcyxcbiAgICAgICAgICBmaWx0ZXJJZDogbnVsbFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZWRpdG9yOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgICAgICAgIGZlYXR1cmVzOiBbLi4uc3RhdGUuZWRpdG9yLmZlYXR1cmVzLCBub25lRmlsdGVyRmVhdHVyZV0sXG4gICAgICAgICAgc2VsZWN0ZWRGZWF0dXJlOiBub25lRmlsdGVyRmVhdHVyZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHtsYXllcklkfSA9IHN0YXRlLmZpbHRlcnNbZmlsdGVySWR4XSB8fCBbXTtcbiAgICBjb25zdCBpc0xheWVySW5jbHVkZWQgPSBsYXllcklkLmluY2x1ZGVzKGxheWVyLmlkKTtcbiAgICBjb25zdCBmaWx0ZXIgPSBzdGF0ZS5maWx0ZXJzW2ZpbHRlcklkeF07XG5cbiAgICBuZXdMYXllcklkID0gaXNMYXllckluY2x1ZGVkXG4gICAgICA/IC8vIGlmIGxheWVyIGlzIGluY2x1ZGVkLCByZW1vdmUgaXRcbiAgICAgICAgZmlsdGVyLmxheWVySWQuZmlsdGVyKGwgPT4gbCAhPT0gbGF5ZXIuaWQpXG4gICAgICA6IFsuLi5maWx0ZXIubGF5ZXJJZCwgbGF5ZXIuaWRdO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIHdlIGhhdmVuJ3QgY3JlYXRlIHRoZSBwb2x5Z29uIGZpbHRlciwgY3JlYXRlIGl0XG4gICAgY29uc3QgbmV3RmlsdGVyID0gZ2VuZXJhdGVQb2x5Z29uRmlsdGVyKFtdLCBmZWF0dXJlKTtcbiAgICBmaWx0ZXJJZHggPSBzdGF0ZS5maWx0ZXJzLmxlbmd0aDtcblxuICAgIC8vIGFkZCBmZWF0dXJlLCByZW1vdmUgZmVhdHVyZSBmcm9tIGVpZHRvclxuICAgIG5ld1N0YXRlID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBmaWx0ZXJzOiBbLi4uc3RhdGUuZmlsdGVycywgbmV3RmlsdGVyXSxcbiAgICAgIGVkaXRvcjoge1xuICAgICAgICAuLi5zdGF0ZS5lZGl0b3IsXG4gICAgICAgIGZlYXR1cmVzOiBzdGF0ZS5lZGl0b3IuZmVhdHVyZXMuZmlsdGVyKGYgPT4gZi5pZCAhPT0gZmVhdHVyZS5pZCksXG4gICAgICAgIHNlbGVjdGVkRmVhdHVyZTogbmV3RmlsdGVyLnZhbHVlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzZXRGaWx0ZXJVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgaWR4OiBmaWx0ZXJJZHgsXG4gICAgcHJvcDogJ2xheWVySWQnLFxuICAgIHZhbHVlOiBuZXdMYXllcklkXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc29ydFRhYmxlQ29sdW1uVXBkYXRlcihzdGF0ZSwge2RhdGFJZCwgY29sdW1uLCBtb2RlfSkge1xuICBjb25zdCBkYXRhc2V0ID0gc3RhdGUuZGF0YXNldHNbZGF0YUlkXTtcbiAgaWYgKCFkYXRhc2V0KSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGlmICghbW9kZSkge1xuICAgIGNvbnN0IGN1cnJlbnRNb2RlID0gZ2V0KGRhdGFzZXQsIFsnc29ydENvbHVtbicsIGNvbHVtbl0pO1xuICAgIG1vZGUgPSBjdXJyZW50TW9kZVxuICAgICAgPyBPYmplY3Qua2V5cyhTT1JUX09SREVSKS5maW5kKG0gPT4gbSAhPT0gY3VycmVudE1vZGUpXG4gICAgICA6IFNPUlRfT1JERVIuQVNDRU5ESU5HO1xuICB9XG5cbiAgY29uc3Qgc29ydGVkID0gc29ydERhdGFzZXRCeUNvbHVtbihkYXRhc2V0LCBjb2x1bW4sIG1vZGUpO1xuICByZXR1cm4gc2V0KFsnZGF0YXNldHMnLCBkYXRhSWRdLCBzb3J0ZWQsIHN0YXRlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpblRhYmxlQ29sdW1uVXBkYXRlcihzdGF0ZSwge2RhdGFJZCwgY29sdW1ufSkge1xuICBjb25zdCBkYXRhc2V0ID0gc3RhdGUuZGF0YXNldHNbZGF0YUlkXTtcbiAgaWYgKCFkYXRhc2V0KSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IGZpZWxkID0gZGF0YXNldC5maWVsZHMuZmluZChmID0+IGYubmFtZSA9PT0gY29sdW1uKTtcbiAgaWYgKCFmaWVsZCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGxldCBwaW5uZWRDb2x1bW5zO1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhc2V0LnBpbm5lZENvbHVtbnMpICYmIGRhdGFzZXQucGlubmVkQ29sdW1ucy5pbmNsdWRlcyhmaWVsZC5uYW1lKSkge1xuICAgIC8vIHVucGluIGl0XG4gICAgcGlubmVkQ29sdW1ucyA9IGRhdGFzZXQucGlubmVkQ29sdW1ucy5maWx0ZXIoY28gPT4gY28gIT09IGZpZWxkLm5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHBpbm5lZENvbHVtbnMgPSAoZGF0YXNldC5waW5uZWRDb2x1bW5zIHx8IFtdKS5jb25jYXQoZmllbGQubmFtZSk7XG4gIH1cblxuICByZXR1cm4gc2V0KFsnZGF0YXNldHMnLCBkYXRhSWQsICdwaW5uZWRDb2x1bW5zJ10sIHBpbm5lZENvbHVtbnMsIHN0YXRlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlUYWJsZUNvbHVtblVwZGF0ZXIoc3RhdGUsIHtkYXRhSWQsIGNvbHVtbn0pIHtcbiAgY29uc3QgZGF0YXNldCA9IHN0YXRlLmRhdGFzZXRzW2RhdGFJZF07XG4gIGlmICghZGF0YXNldCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCBmaWVsZElkeCA9IGRhdGFzZXQuZmllbGRzLmZpbmRJbmRleChmID0+IGYubmFtZSA9PT0gY29sdW1uKTtcbiAgaWYgKGZpZWxkSWR4IDwgMCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCB7dHlwZX0gPSBkYXRhc2V0LmZpZWxkc1tmaWVsZElkeF07XG4gIGNvbnN0IHRleHQgPSBkYXRhc2V0LmFsbERhdGEubWFwKGQgPT4gcGFyc2VGaWVsZFZhbHVlKGRbZmllbGRJZHhdLCB0eXBlKSkuam9pbignXFxuJyk7XG5cbiAgY29weSh0ZXh0KTtcblxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogVXBkYXRlIGVkaXRvclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB2aXNpYmxlXG4gKiBAcmV0dXJuIHtPYmplY3R9IG5leHRTdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlRWRpdG9yVmlzaWJpbGl0eShzdGF0ZSwge3Zpc2libGV9KSB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZWRpdG9yOiB7XG4gICAgICAuLi5zdGF0ZS5lZGl0b3IsXG4gICAgICB2aXNpYmxlOiAhc3RhdGUuZWRpdG9yLnZpc2libGVcbiAgICB9XG4gIH07XG59XG4iXX0=