"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _window = require("global/window");

var _visStateSchema = _interopRequireDefault(require("./vis-state-schema"));

var _datasetSchema = _interopRequireDefault(require("./dataset-schema"));

var _mapStyleSchema = _interopRequireDefault(require("./map-style-schema"));

var _mapStateSchema = _interopRequireDefault(require("./map-state-schema"));

var _versions = require("./versions");

var _utils = require("../utils/utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var REDUCER_SCHEMAS = {
  visState: _visStateSchema["default"],
  mapState: _mapStateSchema["default"],
  mapStyle: _mapStyleSchema["default"]
};

var KeplerGLSchema =
/*#__PURE__*/
function () {
  function KeplerGLSchema() {
    (0, _classCallCheck2["default"])(this, KeplerGLSchema);
    this._validVersions = _versions.VERSIONS;
    this._version = _versions.CURRENT_VERSION;
    this._reducerSchemas = REDUCER_SCHEMAS;
    this._datasetSchema = _datasetSchema["default"];
    this._datasetLastSaved = null;
    this._savedDataset = null;
  }
  /**
   * stateToSave = {
   *   datasets: [
   *     {
   *       version: 'v0',
   *       data: {id, label, color, allData, fields}
   *     },
   *     {
   *       version: 'v0',
   *       data: {id, label, color, allData, fields}
   *     }
   *   ],
   *   config: {
   *     version: 'v0',
   *     config: {}
   *   },
   *   info: {
   *     app: 'kepler.gl',
   *     create_at: 'Mon May 28 2018 21:04:46 GMT-0700 (PDT)'
   *   }
   * }
   *
   * Get config and data of current map to save
   * @param {Object} state
   * @returns {{datasets: Object[], config: Object, info: Object}} app state to save
   */


  (0, _createClass2["default"])(KeplerGLSchema, [{
    key: "save",
    value: function save(state) {
      return {
        datasets: this.getDatasetToSave(state),
        config: this.getConfigToSave(state),
        info: _objectSpread({
          app: 'kepler.gl',
          created_at: new Date().toString()
        }, this.getMapInfo(state))
      };
    }
  }, {
    key: "getMapInfo",
    value: function getMapInfo(state) {
      return state.visState.mapInfo;
    }
    /**
     *  Load saved map, argument can be (datasets, config) or ({datasets, config})
     * @param {Object|Array<Object>} savedDatasets
     * @param {Object} savedConfig
     */

  }, {
    key: "load",
    value: function load(savedDatasets, savedConfig) {
      // if pass dataset and config in as a single object
      if (arguments.length === 1 && (0, _utils.isPlainObject)(arguments[0]) && (Array.isArray(arguments[0].datasets) || (0, _utils.isPlainObject)(arguments[0].config))) {
        return this.load(arguments[0].datasets, arguments[0].config);
      }

      return _objectSpread({}, Array.isArray(savedDatasets) ? {
        datasets: this.parseSavedData(savedDatasets)
      } : {}, {}, savedConfig ? {
        config: this.parseSavedConfig(savedConfig)
      } : {});
    }
    /**
     * Get data to save
     * @param {Object} state - app state
     * @returns {{version: String, data: Object}} - dataset to save
     */

  }, {
    key: "getDatasetToSave",
    value: function getDatasetToSave(state) {
      var _this = this;

      var dataChangedSinceLastSave = this.hasDataChanged(state);

      if (!dataChangedSinceLastSave) {
        return this._savedDataset;
      }

      var visState = state.visState;
      var datasets = Object.values(visState.datasets).map(function (ds) {
        return {
          version: _this._version,
          data: _this._datasetSchema[_this._version].save(ds)
        };
      }); // keep a copy of formatted datasets to save

      this._datasetLastSaved = visState.datasets;
      this._savedDataset = datasets;
      return datasets;
    }
    /**
     * Get App config to save
     * @param {Object} state - app state
     * @returns {{version: String, config: Object}} - config to save
     */

  }, {
    key: "getConfigToSave",
    value: function getConfigToSave(state) {
      var _this2 = this;

      var config = Object.keys(this._reducerSchemas).reduce(function (accu, key) {
        return _objectSpread({}, accu, {}, state[key] ? _this2._reducerSchemas[key][_this2._version].save(state[key]) : {});
      }, {});
      return {
        version: this._version,
        config: config
      };
    }
    /**
     * Parse saved data
     * @param {Array} datasets
     * @returns {Object | null} - data to save
     */

  }, {
    key: "parseSavedData",
    value: function parseSavedData(datasets) {
      var _this3 = this;

      return datasets.reduce(function (accu, ds) {
        var validVersion = _this3.validateVersion(ds.version);

        if (!validVersion) {
          return accu;
        }

        accu.push(_this3._datasetSchema[validVersion].load(ds.data));
        return accu;
      }, []);
    }
    /**
     * Parse saved App config
     * @param {String} opt.version - config version
     * @param {Object} opt.config - saved config
     * @param {Object} state - current App State
     * @returns {Object | null} - parsed config
     */

  }, {
    key: "parseSavedConfig",
    value: function parseSavedConfig(_ref) {
      var _this4 = this;

      var version = _ref.version,
          config = _ref.config;
      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var validVersion = this.validateVersion(version);

      if (!validVersion) {
        return null;
      }

      return Object.keys(config).reduce(function (accu, key) {
        return _objectSpread({}, accu, {}, key in _this4._reducerSchemas ? _this4._reducerSchemas[key][validVersion].load(config[key]) : {});
      }, {});
    }
    /**
     * Validate version
     * @param {String} version
     * @returns {String | null} validVersion
     */

  }, {
    key: "validateVersion",
    value: function validateVersion(version) {
      if (!version) {
        _window.console.error('There is no version number associated with this saved map');

        return null;
      }

      if (!this._validVersions[version]) {
        _window.console.error("".concat(version, " is not a valid version"));

        return null;
      }

      return version;
    }
    /**
     * Check if data has changed since last save
     * @param {Object} state
     * @returns {boolean} - whether data has changed or not
     */

  }, {
    key: "hasDataChanged",
    value: function hasDataChanged(state) {
      return this._datasetLastSaved !== state.visState.datasets;
    }
  }]);
  return KeplerGLSchema;
}();

var KeplerGLSchemaManager = new KeplerGLSchema();
var _default = KeplerGLSchemaManager;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWFzL3NjaGVtYS1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbIlJFRFVDRVJfU0NIRU1BUyIsInZpc1N0YXRlIiwidmlzU3RhdGVTY2hlbWEiLCJtYXBTdGF0ZSIsIm1hcFN0YXRlU2NoZW1hIiwibWFwU3R5bGUiLCJtYXBTdHlsZVNjaGVtYSIsIktlcGxlckdMU2NoZW1hIiwiX3ZhbGlkVmVyc2lvbnMiLCJWRVJTSU9OUyIsIl92ZXJzaW9uIiwiQ1VSUkVOVF9WRVJTSU9OIiwiX3JlZHVjZXJTY2hlbWFzIiwiX2RhdGFzZXRTY2hlbWEiLCJkYXRhc2V0U2NoZW1hIiwiX2RhdGFzZXRMYXN0U2F2ZWQiLCJfc2F2ZWREYXRhc2V0Iiwic3RhdGUiLCJkYXRhc2V0cyIsImdldERhdGFzZXRUb1NhdmUiLCJjb25maWciLCJnZXRDb25maWdUb1NhdmUiLCJpbmZvIiwiYXBwIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b1N0cmluZyIsImdldE1hcEluZm8iLCJtYXBJbmZvIiwic2F2ZWREYXRhc2V0cyIsInNhdmVkQ29uZmlnIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwibG9hZCIsInBhcnNlU2F2ZWREYXRhIiwicGFyc2VTYXZlZENvbmZpZyIsImRhdGFDaGFuZ2VkU2luY2VMYXN0U2F2ZSIsImhhc0RhdGFDaGFuZ2VkIiwiT2JqZWN0IiwidmFsdWVzIiwibWFwIiwiZHMiLCJ2ZXJzaW9uIiwiZGF0YSIsInNhdmUiLCJrZXlzIiwicmVkdWNlIiwiYWNjdSIsImtleSIsInZhbGlkVmVyc2lvbiIsInZhbGlkYXRlVmVyc2lvbiIsInB1c2giLCJDb25zb2xlIiwiZXJyb3IiLCJLZXBsZXJHTFNjaGVtYU1hbmFnZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7Ozs7O0FBRUEsSUFBTUEsZUFBZSxHQUFHO0FBQ3RCQyxFQUFBQSxRQUFR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T0FBckIsQ0FBckI7O0FBQ0EsVUFBSSxDQUFDTyxZQUFMLEVBQW1CO0FBQ2pCLGVBQU8sSUFBUDtBQUNEOztBQUVELGFBQU9YLE1BQU0sQ0FBQ08sSUFBUCxDQUFZM0IsTUFBWixFQUFvQjRCLE1BQXBCLENBQ0wsVUFBQ0MsSUFBRCxFQUFPQyxHQUFQO0FBQUEsaUNBQ0tELElBREwsTUFFTUMsR0FBRyxJQUFJLE1BQUksQ0FBQ3RDLGVBQVosR0FDQSxNQUFJLENBQUNBLGVBQUwsQ0FBcUJzQyxHQUFyQixFQUEwQkMsWUFBMUIsRUFBd0NoQixJQUF4QyxDQUE2Q2YsTUFBTSxDQUFDOEIsR0FBRCxDQUFuRCxDQURBLEdBRUEsRUFKTjtBQUFBLE9BREssRUFPTCxFQVBLLENBQVA7QUFTRDtBQUVEOzs7Ozs7OztvQ0FLZ0JOLE8sRUFBUztBQUN2QixVQUFJLENBQUNBLE9BQUwsRUFBYztBQUNaVSx3QkFBUUMsS0FBUixDQUFjLDJEQUFkOztBQUNBLGVBQU8sSUFBUDtBQUNEOztBQUVELFVBQUksQ0FBQyxLQUFLL0MsY0FBTCxDQUFvQm9DLE9BQXBCLENBQUwsRUFBbUM7QUFDakNVLHdCQUFRQyxLQUFSLFdBQWlCWCxPQUFqQjs7QUFDQSxlQUFPLElBQVA7QUFDRDs7QUFFRCxhQUFPQSxPQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7bUNBS2UzQixLLEVBQU87QUFDcEIsYUFBTyxLQUFLRixpQkFBTCxLQUEyQkUsS0FBSyxDQUFDaEIsUUFBTixDQUFlaUIsUUFBakQ7QUFDRDs7Ozs7QUFHSCxJQUFNc0MscUJBQXFCLEdBQUcsSUFBSWpELGNBQUosRUFBOUI7ZUFFZWlELHFCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIwIFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtjb25zb2xlIGFzIENvbnNvbGV9IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuXG5pbXBvcnQgdmlzU3RhdGVTY2hlbWEgZnJvbSAnLi92aXMtc3RhdGUtc2NoZW1hJztcbmltcG9ydCBkYXRhc2V0U2NoZW1hIGZyb20gJy4vZGF0YXNldC1zY2hlbWEnO1xuaW1wb3J0IG1hcFN0eWxlU2NoZW1hIGZyb20gJy4vbWFwLXN0eWxlLXNjaGVtYSc7XG5pbXBvcnQgbWFwU3RhdGVTY2hlbWEgZnJvbSAnLi9tYXAtc3RhdGUtc2NoZW1hJztcblxuaW1wb3J0IHtDVVJSRU5UX1ZFUlNJT04sIFZFUlNJT05TfSBmcm9tICcuL3ZlcnNpb25zJztcbmltcG9ydCB7aXNQbGFpbk9iamVjdH0gZnJvbSAndXRpbHMvdXRpbHMnO1xuXG5jb25zdCBSRURVQ0VSX1NDSEVNQVMgPSB7XG4gIHZpc1N0YXRlOiB2aXNTdGF0ZVNjaGVtYSxcbiAgbWFwU3RhdGU6IG1hcFN0YXRlU2NoZW1hLFxuICBtYXBTdHlsZTogbWFwU3R5bGVTY2hlbWFcbn07XG5cbmNsYXNzIEtlcGxlckdMU2NoZW1hIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fdmFsaWRWZXJzaW9ucyA9IFZFUlNJT05TO1xuICAgIHRoaXMuX3ZlcnNpb24gPSBDVVJSRU5UX1ZFUlNJT047XG4gICAgdGhpcy5fcmVkdWNlclNjaGVtYXMgPSBSRURVQ0VSX1NDSEVNQVM7XG4gICAgdGhpcy5fZGF0YXNldFNjaGVtYSA9IGRhdGFzZXRTY2hlbWE7XG5cbiAgICB0aGlzLl9kYXRhc2V0TGFzdFNhdmVkID0gbnVsbDtcbiAgICB0aGlzLl9zYXZlZERhdGFzZXQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIHN0YXRlVG9TYXZlID0ge1xuICAgKiAgIGRhdGFzZXRzOiBbXG4gICAqICAgICB7XG4gICAqICAgICAgIHZlcnNpb246ICd2MCcsXG4gICAqICAgICAgIGRhdGE6IHtpZCwgbGFiZWwsIGNvbG9yLCBhbGxEYXRhLCBmaWVsZHN9XG4gICAqICAgICB9LFxuICAgKiAgICAge1xuICAgKiAgICAgICB2ZXJzaW9uOiAndjAnLFxuICAgKiAgICAgICBkYXRhOiB7aWQsIGxhYmVsLCBjb2xvciwgYWxsRGF0YSwgZmllbGRzfVxuICAgKiAgICAgfVxuICAgKiAgIF0sXG4gICAqICAgY29uZmlnOiB7XG4gICAqICAgICB2ZXJzaW9uOiAndjAnLFxuICAgKiAgICAgY29uZmlnOiB7fVxuICAgKiAgIH0sXG4gICAqICAgaW5mbzoge1xuICAgKiAgICAgYXBwOiAna2VwbGVyLmdsJyxcbiAgICogICAgIGNyZWF0ZV9hdDogJ01vbiBNYXkgMjggMjAxOCAyMTowNDo0NiBHTVQtMDcwMCAoUERUKSdcbiAgICogICB9XG4gICAqIH1cbiAgICpcbiAgICogR2V0IGNvbmZpZyBhbmQgZGF0YSBvZiBjdXJyZW50IG1hcCB0byBzYXZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgKiBAcmV0dXJucyB7e2RhdGFzZXRzOiBPYmplY3RbXSwgY29uZmlnOiBPYmplY3QsIGluZm86IE9iamVjdH19IGFwcCBzdGF0ZSB0byBzYXZlXG4gICAqL1xuICBzYXZlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGFzZXRzOiB0aGlzLmdldERhdGFzZXRUb1NhdmUoc3RhdGUpLFxuICAgICAgY29uZmlnOiB0aGlzLmdldENvbmZpZ1RvU2F2ZShzdGF0ZSksXG4gICAgICBpbmZvOiB7XG4gICAgICAgIGFwcDogJ2tlcGxlci5nbCcsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9TdHJpbmcoKSxcbiAgICAgICAgLi4udGhpcy5nZXRNYXBJbmZvKHN0YXRlKVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBnZXRNYXBJbmZvKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLnZpc1N0YXRlLm1hcEluZm87XG4gIH1cbiAgLyoqXG4gICAqICBMb2FkIHNhdmVkIG1hcCwgYXJndW1lbnQgY2FuIGJlIChkYXRhc2V0cywgY29uZmlnKSBvciAoe2RhdGFzZXRzLCBjb25maWd9KVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheTxPYmplY3Q+fSBzYXZlZERhdGFzZXRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzYXZlZENvbmZpZ1xuICAgKi9cbiAgbG9hZChzYXZlZERhdGFzZXRzLCBzYXZlZENvbmZpZykge1xuICAgIC8vIGlmIHBhc3MgZGF0YXNldCBhbmQgY29uZmlnIGluIGFzIGEgc2luZ2xlIG9iamVjdFxuICAgIGlmIChcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QoYXJndW1lbnRzWzBdKSAmJlxuICAgICAgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdLmRhdGFzZXRzKSB8fCBpc1BsYWluT2JqZWN0KGFyZ3VtZW50c1swXS5jb25maWcpKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMubG9hZChhcmd1bWVudHNbMF0uZGF0YXNldHMsIGFyZ3VtZW50c1swXS5jb25maWcpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi4oQXJyYXkuaXNBcnJheShzYXZlZERhdGFzZXRzKSA/IHtkYXRhc2V0czogdGhpcy5wYXJzZVNhdmVkRGF0YShzYXZlZERhdGFzZXRzKX0gOiB7fSksXG4gICAgICAuLi4oc2F2ZWRDb25maWcgPyB7Y29uZmlnOiB0aGlzLnBhcnNlU2F2ZWRDb25maWcoc2F2ZWRDb25maWcpfSA6IHt9KVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRhdGEgdG8gc2F2ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgLSBhcHAgc3RhdGVcbiAgICogQHJldHVybnMge3t2ZXJzaW9uOiBTdHJpbmcsIGRhdGE6IE9iamVjdH19IC0gZGF0YXNldCB0byBzYXZlXG4gICAqL1xuICBnZXREYXRhc2V0VG9TYXZlKHN0YXRlKSB7XG4gICAgY29uc3QgZGF0YUNoYW5nZWRTaW5jZUxhc3RTYXZlID0gdGhpcy5oYXNEYXRhQ2hhbmdlZChzdGF0ZSk7XG4gICAgaWYgKCFkYXRhQ2hhbmdlZFNpbmNlTGFzdFNhdmUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zYXZlZERhdGFzZXQ7XG4gICAgfVxuXG4gICAgY29uc3Qge3Zpc1N0YXRlfSA9IHN0YXRlO1xuXG4gICAgY29uc3QgZGF0YXNldHMgPSBPYmplY3QudmFsdWVzKHZpc1N0YXRlLmRhdGFzZXRzKS5tYXAoZHMgPT4gKHtcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBkYXRhOiB0aGlzLl9kYXRhc2V0U2NoZW1hW3RoaXMuX3ZlcnNpb25dLnNhdmUoZHMpXG4gICAgfSkpO1xuXG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgZm9ybWF0dGVkIGRhdGFzZXRzIHRvIHNhdmVcbiAgICB0aGlzLl9kYXRhc2V0TGFzdFNhdmVkID0gdmlzU3RhdGUuZGF0YXNldHM7XG4gICAgdGhpcy5fc2F2ZWREYXRhc2V0ID0gZGF0YXNldHM7XG5cbiAgICByZXR1cm4gZGF0YXNldHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IEFwcCBjb25maWcgdG8gc2F2ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgLSBhcHAgc3RhdGVcbiAgICogQHJldHVybnMge3t2ZXJzaW9uOiBTdHJpbmcsIGNvbmZpZzogT2JqZWN0fX0gLSBjb25maWcgdG8gc2F2ZVxuICAgKi9cbiAgZ2V0Q29uZmlnVG9TYXZlKHN0YXRlKSB7XG4gICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmtleXModGhpcy5fcmVkdWNlclNjaGVtYXMpLnJlZHVjZShcbiAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIC4uLihzdGF0ZVtrZXldID8gdGhpcy5fcmVkdWNlclNjaGVtYXNba2V5XVt0aGlzLl92ZXJzaW9uXS5zYXZlKHN0YXRlW2tleV0pIDoge30pXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgY29uZmlnXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBzYXZlZCBkYXRhXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFzZXRzXG4gICAqIEByZXR1cm5zIHtPYmplY3QgfCBudWxsfSAtIGRhdGEgdG8gc2F2ZVxuICAgKi9cbiAgcGFyc2VTYXZlZERhdGEoZGF0YXNldHMpIHtcbiAgICByZXR1cm4gZGF0YXNldHMucmVkdWNlKChhY2N1LCBkcykgPT4ge1xuICAgICAgY29uc3QgdmFsaWRWZXJzaW9uID0gdGhpcy52YWxpZGF0ZVZlcnNpb24oZHMudmVyc2lvbik7XG4gICAgICBpZiAoIXZhbGlkVmVyc2lvbikge1xuICAgICAgICByZXR1cm4gYWNjdTtcbiAgICAgIH1cbiAgICAgIGFjY3UucHVzaCh0aGlzLl9kYXRhc2V0U2NoZW1hW3ZhbGlkVmVyc2lvbl0ubG9hZChkcy5kYXRhKSk7XG4gICAgICByZXR1cm4gYWNjdTtcbiAgICB9LCBbXSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2Ugc2F2ZWQgQXBwIGNvbmZpZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0LnZlcnNpb24gLSBjb25maWcgdmVyc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0LmNvbmZpZyAtIHNhdmVkIGNvbmZpZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgLSBjdXJyZW50IEFwcCBTdGF0ZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0IHwgbnVsbH0gLSBwYXJzZWQgY29uZmlnXG4gICAqL1xuICBwYXJzZVNhdmVkQ29uZmlnKHt2ZXJzaW9uLCBjb25maWd9LCBzdGF0ZSA9IHt9KSB7XG4gICAgY29uc3QgdmFsaWRWZXJzaW9uID0gdGhpcy52YWxpZGF0ZVZlcnNpb24odmVyc2lvbik7XG4gICAgaWYgKCF2YWxpZFZlcnNpb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhjb25maWcpLnJlZHVjZShcbiAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIC4uLihrZXkgaW4gdGhpcy5fcmVkdWNlclNjaGVtYXNcbiAgICAgICAgICA/IHRoaXMuX3JlZHVjZXJTY2hlbWFzW2tleV1bdmFsaWRWZXJzaW9uXS5sb2FkKGNvbmZpZ1trZXldKVxuICAgICAgICAgIDoge30pXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB2ZXJzaW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2ZXJzaW9uXG4gICAqIEByZXR1cm5zIHtTdHJpbmcgfCBudWxsfSB2YWxpZFZlcnNpb25cbiAgICovXG4gIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICBDb25zb2xlLmVycm9yKCdUaGVyZSBpcyBubyB2ZXJzaW9uIG51bWJlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBzYXZlZCBtYXAnKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdmFsaWRWZXJzaW9uc1t2ZXJzaW9uXSkge1xuICAgICAgQ29uc29sZS5lcnJvcihgJHt2ZXJzaW9ufSBpcyBub3QgYSB2YWxpZCB2ZXJzaW9uYCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVyc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBkYXRhIGhhcyBjaGFuZ2VkIHNpbmNlIGxhc3Qgc2F2ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gd2hldGhlciBkYXRhIGhhcyBjaGFuZ2VkIG9yIG5vdFxuICAgKi9cbiAgaGFzRGF0YUNoYW5nZWQoc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YXNldExhc3RTYXZlZCAhPT0gc3RhdGUudmlzU3RhdGUuZGF0YXNldHM7XG4gIH1cbn1cblxuY29uc3QgS2VwbGVyR0xTY2hlbWFNYW5hZ2VyID0gbmV3IEtlcGxlckdMU2NoZW1hKCk7XG5cbmV4cG9ydCBkZWZhdWx0IEtlcGxlckdMU2NoZW1hTWFuYWdlcjtcbiJdfQ==